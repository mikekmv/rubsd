$RuOBSD: README,v 1.4 2005/11/14 21:17:12 form Exp $
------------------------------- цут хере ---------------------------------


Чё это
~~~~~~

Этакая считалка трафика, использующая BPF на уровне ядра. Все организовано
в  виде  устройства  /dev/ipflow  (LKM)  и  утилиты управления. При работе
используются номера bpf начиная с 32768 (наличия ноды в /dev не требуется)
чтобы  не  мешать обычным программам. Устройство порождает kernel процессы
для  каждого  учитываемого  интерфейса  и  один  главный процесс. Процессы
интерфейсов реагируют на сигналы KILL, TERM (удаление интерфейса из списка
учета) и HUP (сброс статистики интерфейса).


ipflow - утилита управления устройством /dev/ipflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ipflow flush
	- Сброс насчитаного трафика.

ipflow flows [nflows]
	- Просмотр/установка  максимального числа flows трафика (от 512 до
	  102400). Значение по умолчанию 10240.

ipflow [-f] show
	- Просмотр насчитаного трафика.  Если указано опция -f выполняется
	  сброс трафика.

ipflow [-f] load file
	- Загрузка  сохраненного  трафика  из файла. Если указана опция -f
	  перед загрузкой выполняется сброс насчитаного трафика.

ipflow [-afy] save file
	- Сохранение  трафика  в  файл.  Если указана опция -f выполняется
	  сброс  трафика.   Если  указана  опция  -a  сохраненный   трафик
	  дописывается  в  конец  файла,  иначе  файл переписывается. Если
	  указана опция -y после записи файла выполняется fsync().

ipflow add interface [-F file | expression]
	- Добавить  интерфейс  в  список  учета.  Можно  указать   tcpdump
	  выражение для bpf фильтра или файл содержащий выражение.

ipflow set interface [-F file | expression]
	- Установить bpf фильтр для интерфейса.

ipflow del interface [...]
	- Удалить интерфейсы из списка учета.

ipflow reset interface [...]
	- Сброс статистики интерфейса (recv/drop packets)

ipflow info [interface [...]]
	- Просмотр  информации об указаных или обо всех интерфейсах списка
	  учета.

ipflow version
	- Печатает версию устройства /dev/ipflow.


ipfshow - интерактивный просмотр трафика
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ipfshow [-hr] [-o sortmode] [-s seconds]

-h
	- Задает human readable формат для вывода числа байт в потоке

-s seconds
	- Задает число секунд между обновлениями экрана.

-o sortmode
	- Задает порядок сортировки:
		first	- по времени первого пакета в потоке
		last	- по времени последнего пакета в потоке
		src	- по адресу источника
		dst	- по адресу приемника
		pkts	- по числу пакетов
		octets	- по числу байт

-r
	- Задает обратный порядок сортировки.

По  умолчанию  производится  используется  обратный  порядок сортировки по
времени последнего пакета.  Во время работы программы возможно перемещение
по  экранам с помощью клавиш Home/End/Up/PgUp/Down/PgDn. Для терминалов не
имеющих   данных   клавиш   можно   пользоваться   следующими   клавишами:
Clrl/U (Up), Ctrl/D (Down), Ctrl/A (Home), Ctrl/E (End).  Также  можно  во
время работы менять метод сортировки с помощью клавиш F (first), L (last),
S (src),  D (dst),  P (pkts),  O (octets).   Клавиша  R   меняет   порядок
сортировки  на  обратный.   Клавиша  H  переключает  формат  вывода   байт
(числовой/human readable).  Клавиши  Ctrl/L,  Ctrl/W  или  Ctrl/R вызывают
перерисовку экрана.


Пример использования
~~~~~~~~~~~~~~~~~~~~

В приведенном  ниже примере ipflow автоматически запускается при  загрузке
системы.  Насчитаный  трафик  автоматически  сохраняется   на   диске  при
завершении работы системы и восстанавливается при загрузке.

Создаем каталог /etc/ipflow:

# mkdir -m 700 /etc/ipflow

Создаем  файлы  фильтров  для  каждого  интерфейса,  на  котором требуется
считать:

# vi /etc/ipflow/ipflow.sk0
not ( src net 85.118.224.0/21 and dst net 85.118.224.0/21 ) and
not net 10.0.0.0/8 and
not net 172.16.0.0/12 and
not net 192.168.0.0/16 and
not ether broadcast

В файл /etc/rc.securelevel добавляем команды запуска:

if [ -f /usr/lkm/ipflow.o -a -x /usr/local/sbin/ipflow ]; then
	echo -n ' ipflowd'
	# подгружаем LKM ipflow
	if modload /usr/lkm/ipflow.o >/dev/null; then
		# для каждого файла /etc/ipflow/ipflow.ifX
		# включаем интерфейс и подгружаем выражение BPF фильтра
		for file in /etc/ipflow/ipflow.*; do
			iface=${file#/etc/ipflow/ipflow.}
			[ "$iface" = "*" -o "$iface" = "dump" ] && continue
			/usr/local/sbin/ipflow add $iface -F $file
		done
		# устанавливаем максимальное значение flows
		/usr/local/sbin/ipflow flows 102400
		# если есть ранее сохраненный трафик - восстанавливаем
		if [ -r /etc/ipflow/ipflow.dump ]; then
			/usr/local/sbin/ipflow load /etc/ipflow/ipflow.dump
		fi
	fi
fi

В файл /etc/rc.shutdown добавляем команды сохранения трафика:

if [ -x /usr/local/sbin/ipflow -a -c /dev/ipflow ]; then
	# сохраняем трафик
	/usr/local/sbin/ipflow -y save /etc/ipflow/ipflow.dump
fi


Структуры данных /dev/ipflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

struct ipflow {
	time_t		if_first;	/* время первого пакета */
	time_t		if_last;	/* время последнего пакета */
	in_addr_t	if_src;		/* адрес источника */
	in_addr_t	if_dst; 	/* адрес приемника */
	u_int64_t	if_pkts;   	/* число пакетов */
	u_int64_t	if_octets;	/* число байт */
};                                          

struct ipflow_req {
	struct ipflow	*irq_flows;	/* указатель на массив flows */
	size_t		irq_nflows;	/* количество flows в массиве */
};

struct ipflow_ifreq {
	char		iir_name[IFNAMSIZ];	/* имя интерфейса */
	caddr_t		iir_data;	/* адрес буфера */
	size_t		iir_count;	/* количество элементов */
	dev_t		iir_dev;	/* bpf устройство интерфейса */
	u_int		iir_dlt;	/* link-type интерфейса */
	u_int		iir_recv;	/* принятые пакеты */
	u_int		iir_drop;	/* отброшенные пакеты */
	pid_t		iir_pid;	/* PID процесса интерфейса */
#define iir_bprog	iir_data
};

struct ipflow_info {
	u_int		ifi_recv;	/* число учтенных flows */
	u_int		ifi_drop;	/* число отброшеных flows */
	u_int		ifi_max;	/* максимальное число flows */
	pid_t		ifi_pid;	/* PID главного процесса */
};

struct ipflow_version {
	u_int		iv_major;	/* major номер версии */
	u_int		iv_minor;	/* minor номер версии */
};


Управление устройством /dev/ipflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

При выполнении чтения с устройства в буфер считываются  flows  насчитаного
трафика.  Размер буфера должен быть достаточным для приема всех насчитаных
flows  и  быть  кратным  sizeof(struct ipflow).  В  случае  недостаточного
размера буфера возвращается ошибка ENOMEM.

При  выполнении  записи  на  устройство  flows  из  буфера  добавляются  к
насчитаным. Размер буфера должен быть кратным sizeof(struct ipflow).

Устройство  поддерживает  kevent.  При  этом EVFILT_READ возвращает в поле
data число насчитаных flows, а EVFILT_WRITE максимальное число flows.

Для програмного управления /dev/ipflow необходимы следующие инклуды:

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <net/if.h>

#include "ipflow.h"


ioctl(int fd, IIOCFFLOWS)
	- Сброс насчитаного трафика.

ioctl(int fd, IIOCGFLOWS, struct ipflow_req *irq)
	- Считыавание насчитаного трафика со сбросом. Размер буфера должен
	  быть достаточным для приема всех насчитаных flows и быть кратным
	  sizeof(struct ipflow). После выполнения поле irq_nflows содержит
	  число flows.  Если перед выполнением irq_flows == 0 возвращается
	  только  число  насчитаных flows.  В случае недостаточного буфера
	  возвращается ошибка ENOMEM.

ioctl(int fd, IIOCSFLOWS, struct ipflow_req *irq)
	- Запись flows в устройство с предварительным сбросом насчитаного.

ioctl(int fd, IIOCGNFLOWS, size_t *nflows)
	- Считывание максимального количества flows.

ioctl(int fd, IIOCSNFLOWS, size_t *nflows)
	- Установка максимального количества flows.

ioctl(int fd, IIOCADDIF, struct ipflow_ifreq *iir)
	- Добавление интерфейса в список учета.

ioctl(int fd, IIOCDELIF, struct ipflow_ifreq *iir)
	- Удаление интерфейса из списка учета.

ioctl(int fd, IIOCSETF, struct ipflow_ifreq *iir)
	- Установка  bpf  фильтра  для инфтерфейса.  Поле iir_bprog должно
	  содержать адрес структуры bpf_program.

ioctl(int fd, IIOCGIFCONF, struct ipflow_ifreq *iir)
	- Получение конфигурации и статистики интерфейса.

ioctl(int fd, IIOCGIFLIST, struct ipflow_ifreq *iir)
	- Получения  конфигурации  и  статистики  всех  интерфейсов.  Поле
	  iir_data  должно  ссылаться на массив struct ipflow_ifreq,  поле
	  iir_count должно содержать  число  элементов  в  массиве.  После
	  выполнения поле iir_count содержит число интерфейсов. Если перед
	  вызовом  iir_count == 0  возвращается  только число интерфейсов.
	  Если  размер  буфера недостаточен для приема информации обо всех
	  интерфейсах,  информация вовзаращается в пределах размера буфера
	  и выдается ошибка ENOMEM.

ioctl(int fd, IIOCFLUSHIF, struct ipflow_ifreq *iir)
	- Сброс статистики (received/dropped packets) для интерфейса.

ioctl(int fd, IIOCVERSION, struct ipflow_version *iv)
	- Получение номера версии ipflow.

ioctl(int fd, IIOCGINFO, struct ipflow_info *iif)
	- Получение информации об устройстве.


------------------------------ и хере цут --------------------------------
ЦОПЫРИГХТ (Ц) 2005 ОЛЕГ САФИУЛЛИН <ФОРМЮПДП-11.ОРГ.РУ>
АЛЛ РИГХТС РЕСЕРЖЕД.

РЕДИСТРИБУТИОН  АНД  УСЕ  ИН  СОУРЦЕ  АНД  БИНАРЫ  ФОРМС,  ВИТХ ОР ВИТХОУТ
МОДИФИЦАТИОН,  АРЕ  ПЕРМИТТЕД  ПРОЖИДЕД  ТХАТ  ТХЕ  ФОЛЛОВИНГ   ЦОНДИТИОНС
АРЕ МЕТ:
1. РЕДИСТРИБУТИОНС  ОФ  СОУРЦЕ ЦОДЕ МУСТ РЕТАИН ТХЕ АБОЖЕ ЦОПЫРИГХТ НОТИЦЕ
   УНМОДИФИЕД, ТХИС ЛИСТ ОФ ЦОНДИТИОНС, АНД ТХЕ ФОЛЛОВИНГ ДИСЦЛАИМЕР.
2. РЕДИСТРИБУТИОНС  ИН  БИНАРЫ  ФОРМ  МУСТ  РЕПРОДУЦЕ  ТХЕ АБОЖЕ ЦОПЫРИГХТ
   НОТИЦЕ,  ТХИС  ЛИСТ  ОФ  ЦОНДИТИОНС АНД ТХЕ ФОЛЛОВИНГ ДИСЦЛАИМЕР ИН ТХЕ
   ДОЦУМЕНТАТИОН АНД/ОР ОТХЕР МАТЕРИАЛС ПРОЖИДЕД ВИТХ ТХЕ ДИСТРИБУТИОН.

ТХИС СОФТВАРЕ ИС ПРОЖИДЕД БЫ ТХЕ АУТХОР АНД ЦОНТРИБУТОРС ``АС ИС'' АНД АНЫ
ЕЬПРЕСС  ОР ИМПЛИЕД ВАРРАНТИЕС, ИНЦЛУДИНГ, БУТ НОТ ЛИМИТЕД ТО, ТХЕ ИМПЛИЕД
ВАРРАНТИЕС  ОФ  МЕРЦХАНТАБИЛИТЫ  АНД  ФИТНЕСС ФОР А ПАРТИЦУЛАР ПУРПОСЕ АРЕ
ДИСЦЛАИМЕД. ИН НО ЕЖЕНТ СХАЛЛ ТХЕ АУТХОР ОР ЦОНТРИБУТОРС БЕ ЛИАБЛЕ ФОР АНЫ
ДИРЕЦТ, ИНДИРЕЦТ, ИНЦИДЕНТАЛ, СПЕЦИАЛ, ЕЬЕМПЛАРЫ, ОР ЦОНСЕЯУЕНТИАЛ ДАМАГЕС
(ИНЦЛУДИНГ,  БУТ  НОТ  ЛИМИТЕД  ТО,  ПРОЦУРЕМЕНТ  ОФ  СУБСТИТУТЕ  ГООДС ОР
СЕРЖИЦЕС; ЛОСС ОФ УСЕ, ДАТА, ОР ПРОФИТС; ОР БУСИНЕСС ИНТЕРРУПТИОН) ХОВЕЖЕР
ЦАУСЕД  АНД  ОН  АНЫ  ТХЕОРЫ  ОФ  ЛИАБИЛИТЫ,  ВХЕТХЕР  ИН ЦОНТРАЦТ, СТРИЦТ
ЛИАБИЛИТЫ,  ОР ТОРТ (ИНЦЛУДИНГ НЕГЛИГЕНЦЕ ОР ОТХЕРВИСЕ) АРИСИНГ ИН АНЫ ВАЫ
ОУТ  ОФ  ТХЕ  УСЕ  ОФ ТХИС СОФТВАРЕ, ЕЖЕН ИФ АДЖИСЕД ОФ ТХЕ ПОССИБИЛИТЫ ОФ
СУЦХ ДАМАГЕ.
