$RuOBSD$

	Некоторые рассуждения об устройстве ATA драйвера.
			(Design goals)

gluk> Не хотел я делать новый драйвер, но вся жопа в том, что все в драйвере
gluk> тесно переплетается. Корнем многих проблем является устройство xfer
gluk> очередей и линейность драйвера. Фактически нужно переделывать все, чтобы
gluk> нормально работать с concurrent командами. Можно пока оставить только
gluk> интерфейс с контроллером (*chp), но и его придется править.
gluk> Исправляя старый драйвер, очень сложно править и тестировать, то
gluk> что приходится ломать. И еще.. меня достала сложность отладки из-за
gluk> кривизны драйвера. Переписать с нуля, думаю будет проще, чем последова-
gluk> тельно исправлять это Г.
gluk> 
gluk> Драйвер диска видимо будет называться ad (ata disk) и его нужно уметь
gluk> attach'ить вместо wd/wdc. Т.е. старый драйвер необходимо все же сохранить.
gluk> 
gluk> Итак, соображения по устройству драйвера:
gluk> 
gluk> Каждый device (wd/ad, cd/atapiscsi) должен иметь независимую очередь
gluk> из xfer. xfer - структура определяющая операцию которую необходимо
gluk> выполнить.
gluk> Возможно xfer правильнее переименовать в request, т.к. кроме передачи
gluk> данных бывают и другие запросы, впрочем стоит ли их добавлять в общую
gluk> очередь еще нужно подумать.

grange> Сложный вопрос. С одной стороны, трактуя очередь только как
grange> data-stransfer commands, можно легко делать тот же disksort и проч. С
grange> другой строны, разбивая команды на два класса вносится не такая уж
grange> необходимая сложность.

gluk> Очередь из xfer (xfer queue) должна наполняться из *strategy, при этом
gluk> выделяется xfer из pool и производится инициализация необходимых
gluk> параметров,
gluk> partition boundary checks, drive capabilities, and so on. Все это делается
gluk> без блокировки прерываний. Не используются никакие ata_bio, wdc_command,
gluk> scsi_xfer. Вся необходимая информация должна быть в xfer. В этом случае
gluk> не нужно копировать данные из ata_bio в xfer и обратно.
gluk> Объем работы внутри прерывания должен быть минимален (очевидная вещь,
gluk> но судя по текущему драйверу не для всех...). 
gluk> 
gluk> struct xfer не должна содержать указатель на обработчик прерывания, в 
gluk> случае с TQ это не имеет смысла. Обработчик прерывания определяется
gluk> по текущему состоянию driv'а. Мы всегда должны знать какое прерывание
gluk> мы ожидаем (service, dma transfer finish, bus release, control operation
gluk> finish, ...). Впрочем, быть может я здесь и не прав. Не все так просто.
gluk> 
gluk> Необходим какой-то уровень (ata bus layer), который имеет минимальные
gluk> знания об устройстве шины и ее устройств. Например мы имеем на одном
gluk> шлейфе tq-drive и cdrom.
gluk> После того как tq-drive сделает bus-release, мы вместо того
gluk> чтобы засунуть следующую команду из xfer queue, должны проверить есть
gluk> ли запросы в очереди CDROM'а. Если есть запросы в очереди CDROM'а,
gluk> то мы должны запустить драйвер CDROM'а. CDROM скорее всего тоже сделает
gluk> bus release, после чего мы можем забивать очередь tq-driv'a.
gluk> Именно по этой причине я хочу делать отдельные очереди на каждый device.
gluk> Другой пример - нам нужно сделать переинициализацию диска -
gluk> soft reset (SRST), в этом случае ресетятся оба устройства и операцию
gluk> нужно отрабатывать коррекно.
gluk> 
gluk> Придется делать аналог disksort для non-tq drives, т.к. нужно сортировать
gluk> очередь из xfer, а не из struct buf. Что-то я вообще не
gluk> пойму в каком месте происходит инициализация bp->b_cylinder для использо-
gluk> вания в disksort. В драйвере это не делается, если это делается в другом
gluk> месте, то это похоже на идиотизм.
gluk> Хм.. это делается в bounds_check_with_label.
gluk> 
gluk> struct xfer возможно будет иметь callback pointer для вызова wddone и
gluk> аналогов по завершении операции. Если такая функция будет только одна,
gluk> то нет смысла делать callback pointer.
gluk> 
gluk> struct xfer должна содержать указатель на struct buf. Указатель на
gluk> struct channel_softc и drive number возможно будет лучше заменить
gluk> на указатель на drive data (wd_softc).

grange> Я предлагаю придерживаться такой логики: каждый элемент какого-либо
grange> уровня абстракции содержит указатель на верхний и нижний элементы
grange> соответствующих уровней абстракции.

gluk> 
gluk> Timeouts должны быть связаны не с каналом, а с xfer.
gluk> 
gluk> Для упрощения начальной реализации предполагаю использовать только
gluk> LBA режим, не забивать код всякими retries, command logging и пр.
gluk> Поддержка Pre-ATA drives не планируется.
gluk> Atapiscsi нужно будет портировать, когда ata будет работать.
gluk> 
gluk> Определение driv'a от которого пришло прерывание, возможно
gluk> лучше делать через чтение device/head register. Этот метод работает,
gluk> он также используется в текущем atapiscsi.c. При использовании NOP AutoPoll
gluk> такой метод может быть необходим впринципе.
gluk> 
gluk> Думаю имеет смысл сделать кеширование содержимого регистров driv'а:
gluk> atacommand(reg1, reg2, cylin..) {
gluk> 	if (reg1 != drvp->reg1)
gluk> 		write reg1;
gluk> }
gluk> 
gluk> Должна быть одна или несколько функций распознающих LBA48 accesss и
gluk> скрывающие подробности от остальной части драйвера.
gluk> 
gluk> К сожалению без polling mode обойтись нельзя. Такой режим необходим
gluk> для crash dump, когда прерывания могут не работать. В остальных случаях
gluk> наверное можно обойтись без polling, быть может не придется засовывать
gluk> во все участки драйвера: (flags & ATA_POLL).

grange> Разумно. dump сделать отдельно, возможно даже с дублированием кода, но
grange> зато не тащить его заморочки через весь драйвер.

