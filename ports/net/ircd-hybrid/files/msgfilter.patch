--- /dev/null	Tue Nov 27 04:12:28 2007
+++ include/msgfilter.h	Tue Nov 27 03:49:37 2007
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2007 Oleg Safiullin <form@pdp-11.org.ru>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MSGFILTER_H__
+#define __MSGFILTER_H__
+
+#ifndef MSGFILTER_EXP_FILE
+#define MSGFILTER_EXP_FILE		"/etc/ircd/msgfilter.regexps"
+#endif
+
+#ifndef MSGFILTER_MSG_FILE
+#define MSGFILTER_MSG_FILE		"/etc/ircd/msgfilter.message"
+#endif
+
+#define MSGFILTER_EXP_INIT		128
+#define MSGFILTER_EXP_INCR		32
+#define MSGFILTER_MAX_STRLEN		512
+
+__BEGIN_DECLS
+void msgfilter_set(const char *, char *, size_t);
+int msgfilter_found(const char *);
+const char *msgfilter_message(void);
+void msgfilter_setmessage(const char *, char *, size_t);
+void msgfilter_init(char *, size_t);
+__END_DECLS
+
+#endif	/* __MSGFILTER_H__ */
--- modules/m_rehash.c.orig	Mon Jul 17 13:31:35 2006
+++ modules/m_rehash.c	Tue Nov 27 05:11:22 2007
@@ -37,6 +37,7 @@
 #include "msg.h"
 #include "parse.h"
 #include "modules.h"
+#include "msgfilter.h"
 
 static void mo_rehash(struct Client *, struct Client *, int, char **);
 
@@ -115,6 +116,17 @@
                            "%s is forcing re-reading of OPER MOTD file",
                            get_oper_name(source_p));
       read_message_file(&ConfigFileEntry.opermotd);
+      found = 1;
+    }
+    else if (irccmp(parv[1], "FILTER") == 0)
+    {
+      char buf[MSGFILTER_MAX_STRLEN];
+
+      msgfilter_init(buf, sizeof(buf));
+      sendto_one(source_p, ":%s NOTICE %s :%s", me.name, source_p->name, buf);
+      sendto_realops_flags(UMODE_ALL, L_ALL,
+                           "%s is forcing re-loading of message filter",
+                           get_oper_name(source_p));
       found = 1;
     }
 
--- modules/core/m_message.c.orig	Mon Jul 17 13:31:34 2006
+++ modules/core/m_message.c	Tue Nov 27 03:33:25 2007
@@ -39,6 +39,7 @@
 #include "irc_string.h"
 #include "hash.h"
 #include "packet.h"
+#include "msgfilter.h"
 
 struct entity
 {
@@ -211,6 +212,14 @@
          */
 #endif
     flood_endgrace(source_p);
+
+  if (msgfilter_found(parv[2])) {
+    sendto_one(source_p, ":%s NOTICE %s :%s",
+              ID_or_name(source_p, client_p),
+              ID_or_name(source_p, client_p),
+              msgfilter_message());
+    return;
+  }
 
   if (build_target_list(p_or_n, command, client_p, source_p, parv[1],
                         parv[2]) < 0)
--- src/Makefile.in.orig	Tue Nov 27 01:38:47 2007
+++ src/Makefile.in	Tue Nov 27 01:39:11 2007
@@ -81,6 +81,7 @@
  memory.c \
  modules.c \
  motd.c \
+ msgfilter.c \
  numeric.c \
  packet.c \
  parse.c \
--- src/ircd.c.orig	Tue Nov 27 03:37:47 2007
+++ src/ircd.c	Tue Nov 27 03:40:29 2007
@@ -63,6 +63,7 @@
 #include "balloc.h"
 #include "motd.h"
 #include "supported.h"
+#include "msgfilter.h"
 
 /* Try and find the correct name to use with getrlimit() for setting the max.
  * number of files allowed to be open by this process.
@@ -564,6 +565,8 @@
   /* set initialVMTop before we allocate any memory */
   initialVMTop = get_vm_top();
 #endif
+
+  msgfilter_init(NULL, 0);
 
   /* save server boot time right away, so getrusage works correctly */
   set_time();
--- /dev/null	Tue Nov 27 05:06:53 2007
+++ src/msgfilter.c	Tue Nov 27 05:06:33 2007
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) 2007 Oleg Safiullin <form@pdp-11.org.ru>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <errno.h>
+#include <regex.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "msgfilter.h"
+
+
+static const u_char trans_tab[] = {
+	'\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
+	'\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f',
+	'\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
+	'\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f',
+	'\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27',
+	'\x28', '\x29', '\x2a', '\x2b', '\x2c', '\x2d', '\x2e', '\x2f',
+	'\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37',
+	'\x38', '\x39', '\x3a', '\x3b', '\x3c', '\x3d', '\x3e', '\x3f',
+	'\x40', '\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47',
+	'\x48', '\x49', '\x4a', '\x4b', '\x4c', '\x4d', '\x4e', '\x4f',
+	'\x50', '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57',
+	'\x58', '\x59', '\x5a', '\x5b', '\x5c', '\x5d', '\x5e', '\x5f',
+	'\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67',
+	'\x68', '\x69', '\x6a', '\x6b', '\x6c', '\x6d', '\x6e', '\x6f',
+	'\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77',
+	'\x78', '\x79', '\x7a', '\x7b', '\x7c', '\x7d', '\x7e', '\x7f',
+	'\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
+	'\x88', '\x89', '\x8a', '\x8b', '\x8c', '\x8d', '\x8e', '\x8f',
+	'\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
+	'\x98', '\x99', '\x9a', '\x9b', '\x9c', '\x9d', '\x9e', '\x9f',
+	'\xa0', '\xa1', '\xa2', '\xb8', '\xa4', '\xa5', '\xa6', '\xa7',
+	'\xb3', '\xa9', '\xaa', '\xab', '\xac', '\xad', '\xae', '\xaf',
+	'\xb0', '\xb1', '\xb2', '\xa8', '\xb4', '\xb5', '\xb6', '\xb7',
+	'\xa3', '\xb9', '\xba', '\xbb', '\xbc', '\xbd', '\xbe', '\xbf',
+	'\xe1', '\xe2', '\xf7', '\xe7', '\xe4', '\xe5', '\xf6', '\xfa',
+	'\xe9', '\xea', '\xeb', '\xec', '\xed', '\xee', '\xef', '\xf0',
+	'\xf2', '\xf3', '\xf4', '\xf5', '\xe6', '\xe8', '\xe3', '\xfe',
+	'\xfb', '\xfd', '\xff', '\xf9', '\xf8', '\xfc', '\xe0', '\xf1',
+	'\xc1', '\xc2', '\xd7', '\xc7', '\xc4', '\xc5', '\xd6', '\xda',
+	'\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce', '\xcf', '\xd0',
+	'\xd2', '\xd3', '\xd4', '\xd5', '\xc6', '\xc8', '\xc3', '\xde',
+	'\xdb', '\xdd', '\xdf', '\xd9', '\xd8', '\xdc', '\xc0', '\xd1'
+};
+
+static const u_char untrans_tab[] = {
+	'\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
+	'\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f',
+	'\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
+	'\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f',
+	'\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27',
+	'\x28', '\x29', '\x2a', '\x2b', '\x2c', '\x2d', '\x2e', '\x2f',
+	'\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37',
+	'\x38', '\x39', '\x3a', '\x3b', '\x3c', '\x3d', '\x3e', '\x3f',
+	'\x40', '\x41', '\x42', '\x43', '\x44', '\x45', '\x46', '\x47',
+	'\x48', '\x49', '\x4a', '\x4b', '\x4c', '\x4d', '\x4e', '\x4f',
+	'\x50', '\x51', '\x52', '\x53', '\x54', '\x55', '\x56', '\x57',
+	'\x58', '\x59', '\x5a', '\x5b', '\x5c', '\x5d', '\x5e', '\x5f',
+	'\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67',
+	'\x68', '\x69', '\x6a', '\x6b', '\x6c', '\x6d', '\x6e', '\x6f',
+	'\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77',
+	'\x78', '\x79', '\x7a', '\x7b', '\x7c', '\x7d', '\x7e', '\x7f',
+	'\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
+	'\x88', '\x89', '\x8a', '\x8b', '\x8c', '\x8d', '\x8e', '\x8f',
+	'\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
+	'\x98', '\x99', '\x9a', '\x9b', '\x9c', '\x9d', '\x9e', '\x9f',
+	'\xa0', '\xa1', '\xa2', '\xb8', '\xa4', '\xa5', '\xa6', '\xa7',
+	'\xb3', '\xa9', '\xaa', '\xab', '\xac', '\xad', '\xae', '\xaf',
+	'\xb0', '\xb1', '\xb2', '\xa8', '\xb4', '\xb5', '\xb6', '\xb7',
+	'\xa3', '\xb9', '\xba', '\xbb', '\xbc', '\xbd', '\xbe', '\xbf',
+	'\xfe', '\xe0', '\xe1', '\xf6', '\xe4', '\xe5', '\xf4', '\xe3',
+	'\xf5', '\xe8', '\xe9', '\xea', '\xeb', '\xec', '\xed', '\xee',
+	'\xef', '\xff', '\xf0', '\xf1', '\xf2', '\xf3', '\xe6', '\xe2',
+	'\xfc', '\xfb', '\xe7', '\xf8', '\xfd', '\xf9', '\xf7', '\xfa',
+	'\xde', '\xc0', '\xc1', '\xd6', '\xc4', '\xc5', '\xd4', '\xc3',
+	'\xd5', '\xc8', '\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce',
+	'\xcf', '\xdf', '\xd0', '\xd1', '\xd2', '\xd3', '\xc6', '\xc2',
+	'\xdc', '\xdb', '\xc7', '\xd8', '\xdd', '\xd9', '\xd7', '\xda'
+};
+
+static const u_char tolower_tab[] = {
+	'\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07',
+	'\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f',
+	'\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17',
+	'\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f',
+	'\x20', '\x21', '\x22', '\x23', '\x24', '\x25', '\x26', '\x27',
+	'\x28', '\x29', '\x2a', '\x2b', '\x2c', '\x2d', '\x2e', '\x2f',
+	'\x30', '\x31', '\x32', '\x33', '\x34', '\x35', '\x36', '\x37',
+	'\x38', '\x39', '\x3a', '\x3b', '\x3c', '\x3d', '\x3e', '\x3f',
+	'\x40', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67',
+	'\x68', '\x69', '\x6a', '\x6b', '\x6c', '\x6d', '\x6e', '\x6f',
+	'\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77',
+	'\x78', '\x79', '\x7a', '\x7b', '\x7c', '\x7d', '\x5e', '\x5f',
+	'\x60', '\x61', '\x62', '\x63', '\x64', '\x65', '\x66', '\x67',
+	'\x68', '\x69', '\x6a', '\x6b', '\x6c', '\x6d', '\x6e', '\x6f',
+	'\x70', '\x71', '\x72', '\x73', '\x74', '\x75', '\x76', '\x77',
+	'\x78', '\x79', '\x7a', '\x7b', '\x7c', '\x7d', '\x7e', '\x7f',
+	'\x80', '\x81', '\x82', '\x83', '\x84', '\x85', '\x86', '\x87',
+	'\x88', '\x89', '\x8a', '\x8b', '\x8c', '\x8d', '\x8e', '\x8f',
+	'\x90', '\x91', '\x92', '\x93', '\x94', '\x95', '\x96', '\x97',
+	'\x98', '\x99', '\x9a', '\x9b', '\x9c', '\x9d', '\x9e', '\x9f',
+	'\xa0', '\xa1', '\xa2', '\xa3', '\xa4', '\xa5', '\xa6', '\xa7',
+	'\xa8', '\xa9', '\xaa', '\xab', '\xac', '\xad', '\xae', '\xaf',
+	'\xb0', '\xb1', '\xb2', '\xa3', '\xb4', '\xb5', '\xb6', '\xb7',
+	'\xb8', '\xb9', '\xba', '\xbb', '\xbc', '\xbd', '\xbe', '\xbf',
+	'\xc0', '\xc1', '\xc2', '\xc3', '\xc4', '\xc5', '\xc6', '\xc7',
+	'\xc8', '\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce', '\xcf',
+	'\xd0', '\xd1', '\xd2', '\xd3', '\xd4', '\xd5', '\xd6', '\xd7',
+	'\xd8', '\xd9', '\xda', '\xdb', '\xdc', '\xdd', '\xde', '\xdf',
+	'\xc0', '\xc1', '\xc2', '\xc3', '\xc4', '\xc5', '\xc6', '\xc7',
+	'\xc8', '\xc9', '\xca', '\xcb', '\xcc', '\xcd', '\xce', '\xcf',
+	'\xd0', '\xd1', '\xd2', '\xd3', '\xd4', '\xd5', '\xd6', '\xd7',
+	'\xd8', '\xd9', '\xda', '\xdb', '\xdc', '\xdd', '\xde', '\xdf'
+};
+
+static char *message;
+static regex_t *regexps;
+static int nregexps;
+
+
+static __inline char
+msgfilter_tolower(char ch)
+{
+	ch = trans_tab[(unsigned char)ch];
+	ch = tolower_tab[(unsigned char)ch];
+
+	return (ch);
+}
+
+static void
+msgfilter_convert(const char *src, char *dst, size_t size)
+{
+	size_t i, len = size - 3;
+	char ch, och = ' ';
+
+	for (dst[0] = '_', i = 1; *src != '\0' && i < len; src++) {
+		switch (*src) {
+		case '\003':
+			++src;
+			if (*src >= '0' && *src <= '9')
+				src++;
+			if (*src >= '0' && *src <= '9')
+				src++;
+			break;
+		case ' ':
+		case '\t':
+		case ',':
+		case '.':
+		case '!':
+		case '?':
+			if (och != ' ')
+				dst[i++] = '_';
+			och = ' ';
+			break;
+		default:
+			switch ((ch = *src)) {
+			case 'A':
+			case 'a':
+				ch = 'Á';
+				break;
+			case 'B':
+				ch = '×';
+				break;
+			case 'C':
+			case 'c':
+				ch = 'Ó';
+				break;
+			case 'E':
+			case 'Å':
+				ch = 'Å';
+				break;
+			case 'H':
+				ch = 'Î';
+				break;
+			case 'O':
+			case 'o':
+				ch = 'Ï';
+				break;
+			case 'P':
+			case 'p':
+				ch = 'Ò';
+				break;
+			case 'T':
+				ch = 'Ô';
+				break;
+			case 'y':
+				ch = 'Õ';
+				break;
+			default:
+				ch = msgfilter_tolower(ch);
+				break;
+			}
+
+			if (ch >= '\0' && ch <= ' ')
+				break;
+
+			dst[i++] = och = ch;
+			break;
+		}
+	}
+
+	if (och != ' ')
+		dst[i++] = '_';
+	dst[i] = '\0';
+}
+
+void
+msgfilter_set(const char *file, char *msgbuf, size_t size)
+{
+	int line = 0, nexps = 0, maxexps = MSGFILTER_EXP_INIT;
+	char buf[MSGFILTER_MAX_STRLEN];
+	regex_t *exps;
+	FILE *fp;
+	void *p;
+
+	if (file != NULL) {
+		if ((exps = malloc(sizeof(*exps) *
+		    MSGFILTER_EXP_INIT)) == NULL) {
+			if (msgbuf != NULL)
+				(void)snprintf(msgbuf, size, "%s",
+				    strerror(errno));
+			return;
+		}
+
+		if ((fp = fopen(file, "r")) == NULL) {
+			if (msgbuf != NULL)
+				(void)snprintf(msgbuf, size, "fopen: %s: %s",
+				    file, strerror(errno));
+			free(exps);
+			return;
+		}
+
+		while (fgets(buf, sizeof(buf), fp) != NULL) {
+			size_t len;
+
+			line++;
+			if (buf[0] == ' ' || buf[0] == '\t')
+				continue; 
+
+			if ((len = strlen(buf)) > 0 && buf[len - 1] == '\n')
+				buf[--len] = '\0';
+			else {
+				if (msgbuf != NULL)
+					(void)snprintf(msgbuf, size, "%s: "
+					    "Line %d too long", file, line);
+				goto error;
+			}
+
+			if (len == 0)
+				continue;
+
+			if (nexps == maxexps) {
+				maxexps += MSGFILTER_EXP_INCR;
+				if ((p = realloc(exps,
+				    sizeof(*exps) * maxexps)) == NULL) {
+					if (msgbuf != NULL)
+						(void)snprintf(msgbuf, size,
+						    "%s", strerror(errno));
+					goto error;
+				}
+
+				exps = p;
+			}
+
+			if (regcomp(&exps[nexps], buf, REG_EXTENDED) != 0) {
+				if (msgbuf != NULL)
+					(void)snprintf(msgbuf, size,
+					    "%s: Invalid regexp at line %d",
+					     file, line);
+				goto error;
+			}
+
+			nexps++;
+		}
+
+		if (ferror(fp)) {
+			if (msgbuf != NULL)
+				(void)snprintf(msgbuf, size, "fgets: %s: %s",
+				    file, strerror(errno));
+		error:	(void)fclose(fp);
+			(void)free(exps);
+			return;
+		}
+
+		if (nexps == 0) {
+			free(exps);
+			exps = NULL;
+		} else if (nexps < maxexps) {
+			if ((p = realloc(exps,
+			    sizeof(*exps) * nexps)) == NULL) {
+				if (msgbuf != NULL)
+					(void)snprintf(msgbuf, size, "%s",
+					    strerror(errno));
+				goto error;
+			}
+
+			exps = p;
+		}
+
+		(void)fclose(fp);
+
+		if (msgbuf != NULL)
+			(void)snprintf(msgbuf, size, "Loaded %d regexp(s)",
+			    nexps);
+	} else {
+		if (msgbuf != NULL)
+			(void)snprintf(msgbuf, size, "Unloaded %d regexp(s)",
+			    nregexps);
+		exps = NULL;
+	}
+
+	free(regexps);
+	regexps = exps;
+	nregexps = nexps;
+}
+
+int
+msgfilter_found(const char *str)
+{
+	char buf[MSGFILTER_MAX_STRLEN];
+	regmatch_t pmatch;
+	int i;
+
+	if (nregexps != 0) {
+		msgfilter_convert(str, buf, sizeof(buf));
+
+		for (i = 0; i < nregexps; i++)
+			if (regexec(&regexps[i], buf, 0, &pmatch, 0) == 0)
+				return (1);
+	}
+
+	return (0);
+}
+
+const char *
+msgfilter_message(void)
+{
+	if (message == NULL)
+		return ("String censored -- try to write it better ;)");
+	return (message);
+}
+
+void
+msgfilter_setmessage(const char *msg, char *msgbuf, size_t size)
+{
+	char *p, *cp;
+
+	if (msg != NULL && strlen(msg) != 0) {
+		if ((p = strdup(msg)) == NULL) {
+			if (msgbuf != NULL)
+				(void)snprintf(msgbuf, size, "%s",
+				    strerror(errno));
+			return;
+		}
+
+		cp = p;
+		while (*cp != '\0') {
+			*cp = untrans_tab[(unsigned char )*cp];
+			cp++;
+		}
+
+		if (msgbuf != NULL)
+			(void)snprintf(msgbuf, size, "Message set");
+	} else {
+		p = NULL;
+		if (msgbuf != NULL)
+			(void)snprintf(msgbuf, size, "Message unset");
+	}
+
+	if (message != NULL)
+		free(message);
+	message = p;
+}
+
+void
+msgfilter_init(char *msgbuf, size_t size)
+{
+	const char *efile = MSGFILTER_EXP_FILE, *mfile = MSGFILTER_MSG_FILE;
+	char emsg[MSGFILTER_MAX_STRLEN], mmsg[MSGFILTER_MAX_STRLEN];
+	char buf[MSGFILTER_MAX_STRLEN];
+	size_t len;
+	FILE *fp;
+
+	if (access(MSGFILTER_EXP_FILE, R_OK) < 0 && errno == ENOENT)
+		efile = NULL;
+
+	msgfilter_set(efile, emsg, sizeof(emsg));
+
+	if (access(MSGFILTER_MSG_FILE, R_OK) < 0 && errno == ENOENT)
+		mfile = NULL;
+
+	if (mfile != NULL) {
+		if ((fp = fopen(mfile, "r")) != NULL) {
+			if (fgets(buf, sizeof(buf), fp) == NULL) {
+				if (ferror(fp))
+					(void)snprintf(mmsg, sizeof(mmsg),
+					    "fgets: %s: %s", mfile,
+					    strerror(errno));
+				else {
+					(void)fclose(fp);
+					goto nomesg;
+				}
+			}
+
+			(void)fclose(fp);
+
+			if ((len = strlen(buf)) > 0 && buf[len - 1] == '\n')
+				buf[--len] = '\0';
+
+			msgfilter_setmessage(buf, mmsg, sizeof(mmsg));
+		} else
+			(void)snprintf(mmsg, sizeof(mmsg), "fopen: %s: %s",
+			    mfile, strerror(errno));
+	} else
+	nomesg:	msgfilter_setmessage(NULL, mmsg, sizeof(mmsg));
+
+	if (msgbuf != NULL)
+		(void)snprintf(msgbuf, size, "MsgFilter: %s, %s", emsg, mmsg);
+}
