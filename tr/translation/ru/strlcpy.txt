
		strlcpy и strlcat -- совместимое, безопасное
			копирование и конкатенация строк.

							Todd C. Millert
					University of Colorado, Boulder

							  Theo de Raadt
							OpenBSD Project

Краткий Обзор

  С увеличением атак на переполнение буфера, все больше и больше программистов
переходит  к  использованию   функций,   таких  как  strncpy()   и   strncat()
ограничивающих размер или длину строки. Наряду с общей тенденцией, стандартные
C функции  начинают использоваться  там, для чего  они не были  разработаны. В
этой статье описывается альтернативный  и  совместимый API  разработанный  для
безопасного копирования строк.

  Может  возникнуть несколько  проблем при использовании strncpy() и strncat()
как безопасной замены strcpy() и strcat().  Функции работают с оканчивающимися
на NUL строками и параметром длины строки, которые могут запутать даже опытных
программистов.  Они  также не  предоставляют  никаких  возможностей определить
когда   происходит  усечение  строки.   Наконец,  strncpy()  заполняет  нулями
оставшуюся часть строки назначения, что влияет на её производительность. Когда
мы проводили  аудит исходных текстов OpenBSD, в большинстве случаев обнаружили
неправильное использование  функций strncpy()  и strncat().  Не все эти случаи
приводили к переполнению буфера, но дали нам понять, что правила использования
strncpy() и  strncat(), как  функций  для  безопасного  оперирования строками,
обычно  понимаются  неправильно.  Предлагаемые  на замену функции, strlcpy() и
strlcat(),   лишены   этих  недостатков,  предоставляя  API  для   безопасного
копирования строк (см. Прототип функций).  Обе функции  гарантируют завершение
строки NUL'ом,  определяя её  размер параметром длины в байтах, и предоставляя
простой  путь для  определения усечения  строки.  Функции  также не  заполняют
NUL'ом неиспользуемые байты в строке назначения.


Предисловие

  В середине 1996, авторы с другими членами проекта OpenBSD,  взялись за аудит
исходных  текстов  OpenBSD.  Атаки на  переполнение  буфера  получили  большое
распространение на форумах  подобных BugTraq.   Мы  нашли  большое  количество
переполнений буфера из-за копирования  безграничных строк используя sprintf(),
strcpy() и strcat(), а так же  циклов манипулирующих со строками  без проверки
на их размер. Кроме того, мы нашли случаи, где программист пытался обезопасить
манипуляции со строками  используя strncpy() и strncat(), но не понял тонкости
программного интерфейса приложения.

  Таким образом,  мы обнаружили, что при аудите кода, нам необходимо проверять
не  только  на  опасное  использование  функций  strcpy() и strcat(), но  и на
неправильное  использование   функций  strncpy()  и  strncat().   Проверка  на
правильное  использование  не  всегда  очевидна, особенно в случае статических
переменных  или  буферов  выделенных используя  calloc().  Мы пришли к выводу,
что необходима замена strncpy() и strncat(), которая смогла бы быть защищённой
от неумелого обращения,  главным образом для облегчения работы программиста, а
так же, для упрощения аудита исходного кода.


Прототип функций

	size_t strlcpy(char *dst, const char *src, size_t size);
	size_t strlcat(char *dst, const char *src, size_t size);


Неправильное представление

  Обычно  происходит  неправильное  представление работы  функции  strncpy() в
том,  что она завершает NUL'ом строку назначения.  Однако это лишь верно, если
размер  исходной строки меньше  параметра  размера.  Это может быть проблемой,
когда  вы копируете ввод пользователя, который может быть неопределённой длины
в  ограниченный  буфер.   Безопасный  способ  использования  strncpy()  в этой
ситуации,  это передать  ей строку назначения  размер которой меньше параметра
размера  и  вручную  завершить  строку.   Только  в  этом  случае  вы получите
гарантированное  завершение строки NUL'ом.  Однако  нет необходимости в ручном
завершении  переменных  static или строк выделенных  используя calloc() потому
что они заполняются  нулями при размещении в памяти. Но не стоит полагаться на
это, так как это может запутать того, кто потом будет использовать код.

  Есть также  неявное  предположение,  что переход  от  strcpy() и strcat() на
strncpy() и strncat() влияет  на производительность.  Это верно для strncat(),
но мы не можем сказать это для strncpy(),  так как она заполняет нулями только
оставшиеся  байты  не используемые для хранения  копируемой строки.  Это может
повлиять на производительность если размер  строки  назначения на много больше
исходной.  Производительность  так  же  зависит  от  архитектуры  и реализации
процессора.

  Наиболее  распространённая ошибка  при использовании strncat()  это неверное
указание  параметра  размера.  Так  как strncat()  гарантирует  NUL-завершение
строки назначения, вы должны не учитывать место для NUL'а в параметре размера.
Это  так же является  не размером  строки назначения, а количеством доступного
пространства.  Почти  всегда  это  значение,   которое   должно вычисляться, в
противоположность константе, и часто вычисляется неправильно.


Чем же помогают strlcpy() и strlcat()?

  Функции  strlcpy() и strlcat() предоставляют  совместимый,  точно выраженный
API для помощи  программисту  в написании  более защищённого кода.  Во-первых,
обе функции strlcpy() и strlcat() гарантируют NUL завершение строки назначения
для всех строк, размер которых не равен нулю. Во-вторых, обе функции принимают
полный размер  строки назначения  как параметр размера.  В большинстве случаев
этот параметр  легко рассчитывается  во  время  компиляции  используя оператор
sizeof.  В конце концов,  strlcpy() и strlcat() не заполняют нулями оставшеюся
строку  назначения (к этому не  относится тот  NUL, который завершает строку).

  Функции strlcpy() и strlcat() возвращают  длину строки, которую они пытаются
создать.  Для strlcpy() это  размер исходной строки;  для strlcat() это размер
строки  назначения  (перед  конкатенацией)  +  размер  исходной строки.  Чтобы
определить усечение строки, программисту лишь надо проверить, что возвращаемое
значение меньше  параметра  размера.  Таким образом,  при усечении строки,  мы
узнаем  количество  необходимых байт  для хранения  всей строки  и программист
может  выделить  больше  места  и повторно  скопировать  строку.  Возвращаемое
значение   имеет  схожею   семантику  с  возвращаемым  значением  у snprintf()
реализованного в BSD и определённого  в развивающейся  спецификации C9X (стоит
заметить,  что не все  реализации snprintf() уподобляются C9X).  Если усечение
строки  не происходит,  программист  получает размер  получившейся строки. Это
полезно,  так как обычно после strncpy() или strncat() используют strlen() для
определения  длины строки.  Используя strlcpy() и strlcat() финальный strlen()
больше не нужен.

  Фрагмент   кода   в  примере 1a  имеет   потенциальное  переполнение  буфера
(переменная   окружения  HOME  контролируется   пользователем   и  может  быть
неопределённой длины)

	strcpy(path, homedir);
	strcat(path, "/");
	strcat(path, ".foorc");
	len = strlen(path);
	
Пример 1a: Фрагмент кода с использованием strcpy() и strcat()

  Фрагмент кода в  примере 1b переделан с использованием strncpy() и strncat()
(заметьте что мы должны завершить строку назначения вручную)

	strncpy(path, homedir, sizeof(path) - 1);
	path[sizeof(path) - 1] = '\0'
	strncat(path, "/", sizeof(path) - strlen(path) - 1);
	strncat(path, ".foorc", sizeof(path) - strlen(path) - 1);
	len = strlen(path);
	
Пример 1b: Переделанный фрагмент кода с использованием strncpy() и strncat()
	
  Простой  фрагмент  кода в примере 1c переделан  с использованием strlcpy() и 
strlcat() API. Он имеет преимущество быть таким же простым как и пример 1a, но
не использует возвращаемые значения нового API.

	strlcpy(path, homedir, sizeof(path));
	strlcat(path, "/", sizeof(path));
	strlcat(path, ".foorc", sizeof(path));
	len = strlen(path);

Пример 1c: Простой фрагмент кода c использованием strlcpy() и strlcat()

  Пример 1c  лёгок   для  чтения  и  понимания,  к нему  легко  можно добавить
дополнительные  проверки.  В примере 1d,  мы проверяем  возвращаемые значения,
чтобы убедится,  что у нас  хватило места  для исходной  строки.  Если нет, мы
возвращаем ошибку. Теперь нам не надо делать финальный вызов strlen().
	
	len = strlcpy(path, homedir, sizeof(path));
	if (len >= sizeof(path))
		return (ENAMETOOLONG);
	len = strlcat(path, "/", sizeof(path));
	if (len >= sizeof(path))
		return (ENAMETOOLONG);
	len = strlcat(path, ".foorc", sizeof(path));
	if (len >= sizeof(path))
		return (ENAMETOOLONG);

Пример 1d: Теперь с проверкой на усечение.


Решения реализации

  Много времени  было уделено решению семантики strlcpy() и strlcat(). Вначале
мы хотели сделать  strlcpy() и strlcat()  идентичными strncpy() и strncat() за
исключением того,  что они  всегда будут  завершать строку назначения  NUL'ом.
Однако,  просматривая   обычное   (неправильное)  использование strncat(),  мы
решили,  чтобы параметр  размера  strlcat()  был размером  полной строки, а не
просто оставшееся свободное место. Возвращаемое значение, решили сделать с той
же семантикой,  что и у snprintf(),  так как она даёт  программисту наибольшею
гибкость для определения усечения.

$RuOBSD: strlcpy.txt,v 1.5 2001/10/04 21:39:40 dfa Exp $
