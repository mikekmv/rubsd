
		strlcpy и strlcat -- совместимое, безопасное
			копирование и конкатенация строк.

							Todd C. Millert
					University of Colorado, Boulder

							  Theo de Raadt
							OpenBSD Project

Краткий Обзор

  С увеличением атак на переполнение буфера, все больше и больше программистов
переходит  к  использованию   функций,   таких  как  strncpy()   и   strncat()
ограничивающих размер или длину строки. Наряду с общей тенденцией, стандартные
C функции  начинают использоваться  там, для чего  они не были  разработаны. В
этой статье описывается альтернативный  и  совместимый API  разработанный  для
безопасного копирования строк.

  Может  возникнуть несколько  проблем при использовании strncpy() и strncat()
как безопасной замены strcpy() и strcat().  Функции работают с оканчивающимися
на NUL строками и параметром длины строки, которые могут запутать даже опытных
программистов.  Они  также не  предоставляют  никаких  возможностей определить
когда   происходит  усечение  строки.   Наконец,  strncpy()  заполняет  нулями
оставшуюся часть строки назначения, что влияет на её производительность. Когда
мы проводили  аудит исходных текстов OpenBSD, в большинстве случаев обнаружили
неправильное использование  функций strncpy()  и strncat().  Не все эти случаи
приводили к переполнению буфера, но дали нам понять, что правила использования
strncpy() и  strncat(), как  функций  для  безопасного  оперирования строками,
обычно  понимаются  неправильно.  Предлагаемые  на замену функции, strlcpy() и
strlcat(),   лишены   этих  недостатков,  предоставляя  API  для   безопасного
копирования строк (см. Прототип функций).  Обе функции  гарантируют завершение
строки NUL'ом,  определяя её  размер параметром длины в байтах, и предоставляя
простой  путь для  определения усечения  строки.  Функции  также не  заполняют
NUL'ом неиспользуемые байты в строке назначения.


Предисловие

  В середине 1996, авторы с другими членами проекта OpenBSD,  взялись за аудит
исходных  текстов  OpenBSD.  Атаки на  переполнение  буфера  получили  большое
распространение на форумах  подобных BugTraq.   Мы  нашли  большое  количество
переполнений буфера из-за копирования  безграничных строк используя sprintf(),
strcpy() и strcat(), а так же  циклов манипулирующих со строками  без проверки
на их размер. Кроме того, мы нашли случаи, где программист пытался обезопасить
манипуляции со строками  используя strncpy() и strncat(), но не понял тонкости
программного интерфейса приложения.

  Таким образом,  мы обнаружили, что при аудите кода, нам необходимо проверять
не  только  на  опасное  использование  функций  strcpy() и strcat(), но  и на
неправильное  использование   функций  strncpy()  и  strncat().   Проверка  на
правильное  использование  не  всегда  очевидна, особенно в случае статических
переменных  или  буферов  выделенных используя  calloc().  Мы пришли к выводу,
что необходима замена strncpy() и strncat(), которая смогла бы быть защищённой
от неумелого обращения,  главным образом для облегчения работы программиста, а
так же, для упрощения аудита исходного кода.


Прототип функций

size_t strlcpy(char *dst, const char *src, size_t size);
size_t strlcat(char *dst, const char *src, size_t size);


Неправильное представление

  Обычно  происходит  неправильное  представление работы  функции  strncpy() в
том,  что она завершает NUL'ом строку назначения.  Однако это лишь верно, если
размер  исходной строки меньше  параметра  размера.  Это может быть проблемой,
когда  вы копируете ввод пользователя, который может быть неопределённой длины
в  ограниченный  буфер.   Безопасный  способ  использования  strncpy()  в этой
ситуации,  это передать  ей строку назначения  размер которой меньше параметра
размера  и  вручную  завершить  строку.   Только  в  этом  случае  вы получите
гарантированное  завершение строки NUL'ом.  Однако  нет необходимости в ручном
завершении  переменных  static или строк выделенных  используя calloc() потому
что они заполняются  нулями при размещении в памяти. Но не стоит полагаться на
это, так как это может запутать того, кто потом будет использовать код.

  Есть также  неявное  предположение,  что переход  от  strcpy() и strcat() на
strncpy() и strncat() влияет  на производительность.  Это верно для strncat(),
но мы не можем сказать это для strncpy(),  так как она заполняет нулями только
оставшиеся  байты  не используемые для хранения  копируемой строки.  Это может
повлиять на производительность если размер  строки  назначения на много больше
исходной.  Производительность  так  же  зависит  от  архитектуры  и реализации
процессора.

  Наиболее  распространённая ошибка  при использовании strncat()  это неверное
указание  параметра  размера.  Так  как strncat()  гарантирует  NUL-завершение
строки назначения, вы должны не учитывать место для NUL'а в параметре размера.
Это  так же является  не размером  строки назначения, а количеством доступного
пространства.  Почти  всегда  это  значение,   которое   должно вычисляться, в
противоположность константе, и часто вычисляется неправильно.

$RuOBSD: strlcpy.txt,v 1.3 2001/10/02 21:54:40 dfa Exp $
