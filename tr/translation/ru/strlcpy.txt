
		strlcpy и strlcat -- совместимое, безопасное
			копирование и конкатенация строк.

							Todd C. Millert
					University of Colorado, Boulder

							  Theo de Raadt
							OpenBSD Project

Краткий Обзор

  С увеличением атак на переполнение буфера, все больше и больше программистов
переходит  к  использованию   функций,   таких  как  strncpy()   и   strncat()
ограничивающих размер или длину строки. Наряду с общей тенденцией, стандартные
C функции  начинают использоваться  там, для чего  они не были  разработаны. В
этой статье описывается альтернативный  и  совместимый API  разработанный  для
безопасного копирования строк.

  Может  возникнуть несколько  проблем при использовании strncpy() и strncat()
как безопасной замены strcpy() и strcat().  Функции работают с оканчивающимися
на NUL строками и параметром длины строки, которые могут запутать даже опытных
программистов.  Они  также не  предоставляют  никаких  возможностей определить
когда   происходит  усечение  строки.   Наконец,  strncpy()  заполняет  нулями
оставшуюся часть строки назначения, что влияет на её производительность. Когда
мы проводили  аудит исходных текстов OpenBSD, в большинстве случаев обнаружили
неправильное использование  функций strncpy()  и strncat().  Не все эти случаи
приводили к переполнению буфера, но дали нам понять, что правила использования
strncpy() и  strncat(), как  функций  для  безопасного  оперирования строками,
обычно  понимаются  неправильно.  Предлагаемые  на замену функции, strlcpy() и
strlcat(),   лишены   этих  недостатков,  предоставляя  API  для   безопасного
копирования строк (см. Прототип функций).  Обе функции  гарантируют завершение
строки NUL'ом,  определяя её  размер параметром длины в байтах, и предоставляя
простой  путь для  определения усечения  строки.  Функции  также не  заполняют
NUL'ом неиспользуемые байты в строке назначения.


Предисловие

  В середине 1996, авторы с другими членами проекта OpenBSD,  взялись за аудит
исходных  текстов  OpenBSD.  Атаки на  переполнение  буфера  получили  большое
распространение на форумах  подобных BugTraq.   Мы  нашли  большое  количество
переполнений буфера из-за копирования  безграничных строк используя sprintf(),
strcpy() и strcat(), а так же  циклов манипулирующих со строками  без проверки
на их размер. Кроме того, мы нашли случаи, где программист пытался обезопасить
манипуляции со строками  используя strncpy() и strncat(), но не понял тонкости
программного интерфейса приложения.

  Таким образом,  мы обнаружили, что при аудите кода, нам необходимо проверять
не  только  на  опасное  использование  функций  strcpy() и strcat(), но  и на
неправильное  использование   функций  strncpy()  и  strncat().   Проверка  на
правильное  использование  не  всегда  очевидна, особенно в случае статических
переменных  или  буферов  выделенных используя  calloc().  Мы пришли к выводу,
что необходима замена strncpy() и strncat(), которая смогла бы быть защищённой
от неумелого обращения,  главным образом для облегчения работы программиста, а
так же, для упрощения аудита исходного кода.


Прототип функций

	size_t strlcpy(char *dst, const char *src, size_t size);
	size_t strlcat(char *dst, const char *src, size_t size);


Неправильное представление

  Обычно  происходит  неправильное  представление работы  функции  strncpy() в
том,  что она завершает NUL'ом строку назначения.  Однако это лишь верно, если
размер  исходной строки меньше  параметра  размера.  Это может быть проблемой,
когда  вы копируете ввод пользователя, который может быть неопределённой длины
в  ограниченный  буфер.   Безопасный  способ  использования  strncpy()  в этой
ситуации,  это передать  ей строку назначения  размер которой меньше параметра
размера  и  вручную  завершить  строку.   Только  в  этом  случае  вы получите
гарантированное  завершение строки NUL'ом.  Однако  нет необходимости в ручном
завершении  переменных  static или строк выделенных  используя calloc() потому
что они заполняются  нулями при размещении в памяти. Но не стоит полагаться на
это, так как это может запутать того, кто потом будет использовать код.

  Есть также  неявное  предположение,  что переход  от  strcpy() и strcat() на
strncpy() и strncat() влияет  на производительность.  Это верно для strncat(),
но мы не можем сказать это для strncpy(),  так как она заполняет нулями только
оставшиеся  байты  не используемые для хранения  копируемой строки.  Это может
повлиять на производительность если размер  строки  назначения на много больше
исходной.  Производительность  так  же  зависит  от  архитектуры  и реализации
процессора.

  Наиболее  распространённая ошибка  при использовании strncat()  это неверное
указание  параметра  размера.  Так  как strncat()  гарантирует  NUL-завершение
строки назначения, вы не должны учитывать место для NUL'а в параметре размера.
Это так же является  не размером  строки назначения,  а количеством доступного
пространства.  Почти  всегда  это  значение,   которое   должно вычисляться, в
противоположность константе, и часто вычисляется неправильно.


Чем же помогают strlcpy() и strlcat()?

  Функции  strlcpy() и strlcat() предоставляют  совместимый,  точно выраженный
API для помощи  программисту  в написании  более защищённого кода.  Во-первых,
обе функции strlcpy() и strlcat() гарантируют NUL завершение строки назначения
для всех строк, размер которых не равен нулю. Во-вторых, обе функции принимают
полный размер  строки назначения  как параметр размера.  В большинстве случаев
этот параметр  легко рассчитывается  во  время  компиляции  используя оператор
sizeof.  В конце концов,  strlcpy() и strlcat() не заполняют нулями оставшеюся
строку  назначения (к этому не  относится тот  NUL, который завершает строку).

  Функции strlcpy() и strlcat() возвращают  длину строки, которую они пытаются
создать.  Для strlcpy() это  размер исходной строки;  для strlcat() это размер
строки  назначения  (перед  конкатенацией)  +  размер  исходной строки.  Чтобы
определить усечение строки, программисту лишь надо проверить, что возвращаемое
значение меньше  параметра  размера.  Таким образом,  при усечении строки,  мы
узнаем  количество  необходимых байт  для хранения  всей строки  и программист
может  выделить  больше  места  и повторно  скопировать  строку.  Возвращаемое
значение   имеет  схожею   семантику  с  возвращаемым  значением  у snprintf()
реализованного в BSD и определённого  в развивающейся  спецификации C9X (стоит
заметить,  что не все  реализации snprintf() уподобляются C9X).  Если усечение
строки  не происходит,  программист  получает размер  получившейся строки. Это
полезно,  так как обычно после strncpy() или strncat() используют strlen() для
определения  длины строки.  Используя strlcpy() и strlcat() финальный strlen()
больше не нужен.

  Фрагмент   кода   в  примере 1a  имеет   потенциальное  переполнение  буфера
(переменная   окружения  HOME  контролируется   пользователем   и  может  быть
неопределённой длины)

	strcpy(path, homedir);
	strcat(path, "/");
	strcat(path, ".foorc");
	len = strlen(path);
	
Пример 1a: Фрагмент кода с использованием strcpy() и strcat()

  Фрагмент кода в  примере 1b переделан с использованием strncpy() и strncat()
(заметьте что мы должны завершить строку назначения вручную)

	strncpy(path, homedir, sizeof(path) - 1);
	path[sizeof(path) - 1] = '\0'
	strncat(path, "/", sizeof(path) - strlen(path) - 1);
	strncat(path, ".foorc", sizeof(path) - strlen(path) - 1);
	len = strlen(path);
	
Пример 1b: Переделанный фрагмент кода с использованием strncpy() и strncat()
	
  Простой  фрагмент  кода в примере 1c переделан  с использованием strlcpy() и 
strlcat() API.  Он преимущественно  такой же простой,  как и пример 1a,  но не
использует возвращаемые значения нового API.

	strlcpy(path, homedir, sizeof(path));
	strlcat(path, "/", sizeof(path));
	strlcat(path, ".foorc", sizeof(path));
	len = strlen(path);

Пример 1c: Простой фрагмент кода c использованием strlcpy() и strlcat()

  Пример 1c  лёгок   для  чтения  и  понимания,  к нему  легко  можно добавить
дополнительные  проверки.  В примере 1d,  мы проверяем  возвращаемые значения,
чтобы убедится,  что у нас  хватило места  для исходной  строки.  Если нет, мы
возвращаем ошибку. Теперь нам не надо делать финальный вызов strlen().
	
	len = strlcpy(path, homedir, sizeof(path));
	if (len >= sizeof(path))
		return (ENAMETOOLONG);
	len = strlcat(path, "/", sizeof(path));
	if (len >= sizeof(path))
		return (ENAMETOOLONG);
	len = strlcat(path, ".foorc", sizeof(path));
	if (len >= sizeof(path))
		return (ENAMETOOLONG);

Пример 1d: Теперь с проверкой на усечение.


Решения реализации

  Много времени  было уделено решению семантики strlcpy() и strlcat(). Вначале
мы хотели сделать  strlcpy() и strlcat()  идентичными strncpy() и strncat() за
исключением того,  что они  всегда будут  завершать строку назначения  NUL'ом.
Однако,  просматривая   обычное   (неправильное)  использование strncat(),  мы
решили,  чтобы параметр  размера  strlcat()  был размером  полной строки, а не
просто оставшееся свободное место. Возвращаемое значение, решили сделать с той
же семантикой,  что и у snprintf(),  так как она даёт  программисту наибольшею
гибкость для определения усечения.


Производительность

  Программисты   стараются   не   использовать  strncpy()   из-за  его  низкой
производительности,  когда буфер назначения  во  много  раз  больше исходного.
Например, группа разработчиков apache заменила вызовы strncpy() на  внутренние
функции,  после чего заметили  повышение  производительности.  Также, в пакете
ncurses  заменили   strncpy(),  и  получили  4-х кратное  увеличение  скорости
утилиты tic.  Наша надежда,  чтоб  в будущем все больше и больше программистов
начинали  использовать  интерфейс  предоставляемый strlcpy(), предпочтительней
чем индивидуальный.

  Чтобы почувствовать  разницу между  strncpy() и strlcpy(), мы запустили тест
программу,  которая  копировала строку  "this is just a test" 1000 раз в буфер
размером 1024 байт.  Это нечто  сложное для  strncpy(),  так как  используется
маленькая строка и  большой буфер,  который  почти  весь  постоянно приходится
заполнять NUL'ами.  В практике, однако, это обычное применение буфера, который
намного больше,  чем ожидаемый ввод пользователя.  Например, буфера содержащие
путь  к файлу размером в  MAXPATHLEN  (1024 байта),  однако большинство файлов 
намного меньше этого размера.  Среднее время работы тест-программы приведено в
таблице 1,  на  HP9000/425t с 25Mhz 68049 CPU  под  управлением  OpenBSD 2.5 и
DEC AXPPCI166  с  166Mhz alpha CPU так же под управлением OpenBSD 2.5. В обоих
случаях  использовались  одинаковые C версии функций  и время это "real time",
полученное утилитой time.

	+--------------------------+
	| cpu     функция    время |
	+--------------------------+
	| m68k    strcpy     0.137 |
	| m68k    strncpy    0.464 |
	| m68k    strlcpy    0.14  |
	| alpha   strcpy     0.018 |
	| alpha   strncpy    0.10  |
	| alpha   strlcpy    0.02  |
	+--------------------------+
	|	 Таблица 1         |
	+--------------------------+

  Как мы видим из таблицы,  время для strncpy() намного хуже, чем для strcpy()
и strlcpy().  Это вероятно не только из-за набивки буфера NUL'ом, но и потому,
что кеш данных CPU заполняется большим потоком нулей.


Что не могут strlcpy() и strlcat()

  Функции   strlcpy()  и  strlcat()  хорошо  подходят  для  работы  с буферами
фиксированного размера, но они не могут заменить strncpy() и strncat() во всех
случаях. Иногда необходимо управлять буферами, которые не являются истинными C
строками (например, строки в struct utmp). Однако, мы бы не стали использовать
эти  псевдо  строки  в  новом  коде,  так  как  они  склонны  к  неправильному
использованию,  и в нашей  практике,  это частый  источник ошибок. Кроме того,
функции strlcpy()  и  strlcat()  не попытка исправить обработку строк в C, они
разработаны для того,  чтобы  сосуществовать с  другими C обработчиками строк.
Если вам необходимы функции строк  позволяющие динамическое размещение, буфера
произвольного размера, посмотрите пакет "astring" от mib software.


Кто использует strlcpy() и strlcat()?

  Функции strlcpy() и strlcat() впервые появились в OpenBSD 2.4. Функции также
были  проверены  для включения  в будущие версии Solaris. Пакеты третьего лица
так же начинают использовать новый API. Например пакет rsync теперь использует
strlcpy() и предоставляет свою версию, если OS её не поддерживает. Мы надеемся
что другие операционные  системы  и приложения  в  будущем  будут использовать
strlcpy() и strlcat(),  и что они когда-нибудь станут стандартом.


Что нового?

  Мы  планируем заменить  strncpy()  и  strncat() на strlcpy()  и  strlcat() в
OpenBSD,  везде где это возможно.  В то время, как новый код в OpenBSD пишется
используя новый  API,  все  ещё  остаётся  код,  который был  модифицирован на
использование  strncpy() и strncat() во время аудита.  Обновление старого кода
к  использование  strlcpy()  и  strlcat()  должно  повысить производительность
программ и раскрыть другие ошибки.


Доступность

  Исходной  код  для  strlcpy()  и  strlcat()  бесплатен  и  доступен  под BSD
лицензией, как часть операционной системы OpenBSD. Вы можете получить исходной
код  и  связанные  с ними  страницы  руководства  используя  анонимный  ftp  с
ftp.openbsd.org  в директории /pub/OpenBSD/src/lib/libc/strings.  Исходной код
для  strlcpy() и strlcat() это strlcpy.c и strlcat.c. Документация (использует
tmac.doc troff макросы) находится в strlcpy.3.


Информация об авторах

  Todd C. Miller был вовлечён в общество свободного программного обеспечения с
1993г,  когда он начал  разработку  пакета sudo.  В 1996г,  он присоединился к
проекту OpenBSD,  как активный  разработчик.  Todd  получил статус бакалавра в
вычислительной технике  от University  of Colorado, Boulder.  В текущий момент
работает  системным  администратором  в  University of Colorado,  Boulder.  Вы
можете связаться с ним по email <Todd.Miller@cs.colorado.edu>.

  Theo De Raadt вовлечён в свободные операционные системы Unix с 1990г. Ранние
разработки, включающие портирование Minix на snu3/50 и amiga, и PDP-11 BSD 2.9
на компьютеры 68039.  Как один  из  основателей проекта  NetBSD,  Theo работал
над поддержанием и улучшением множества компонентов системы включая starc порт
и  реализацию YP,  которая  сейчас  используется  в  большинстве  операционных
систем.  В  1995 Theo  основал проект  OpenBSD,  идея которого сосредоточена в
безопасности,  интегрированной  криптографии и корректном коде. Theo постоянно
работает  над  улучшением  OpenBSD.   Вы  можете  связаться  с  ним  по  email
<deraadt@openbsd.org>.

$RuOBSD: strlcpy.txt,v 1.9 2001/10/09 12:40:09 dfa Exp $
