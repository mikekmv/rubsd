<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<title>11.0 Настройка оптимальной производительности</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta name="resource-type" content="document">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998,1999 by OpenBSD.">
</head>

<body text="#000000" link="#23238E" bgcolor="#ffffffff">
<p><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif"> </p>

<h2><font color="#e00000">11.0 - Настройка оптимальной
производительности</font></h2>

<hr>

<ul>
  <h3>Содержание</h3>
  <li><a href="#11.1">11.1 - Сеть</a></li>
  <li><a href="#11.2">11.2 - Дисковый ввод-вывод</a></li>
  <li><a href="#11.3">11.3 - Настройка kmem</a></li>
  <li><a href="#11.4">11.4 - Выбор оборудования</a></li>
  <li><a href="#11.5">11.5 - Почему мы не используем
    асинхронного монтирования ?</a></li>
  <li><a href="#11.6">11.6 - Настройка разрешения монитора под
    XFree86</a></li>
</ul>

<hr>

<p><a name="11.1"></a> </p>

<h2>11.1 - Сеть</h2>

<p>Если компьютер играет в вашей сети роль
сервера, шлюза или файрвола (firewall) с высокой
нагрузкой, вы должны исключить возможность
нехватки памяти компонентам ядра. </p>

<p>О настройках ядра вы можете прочитать на
странице man <a
HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;apropos=0&amp;sektion=4&amp;format=html">options(4)</a>.
</p>

<p>Для нагруженного сервера может быть полезна
опция NMBCLUSTERS. Она определяет размер кластерной
карты ядра &quot;mbuf&quot;. Если размер этой карты мал,
вы будете получать сообщение &quot;mb_map full&quot;.
Внезапное прекрашение трафика на сетевом
интерфейсе, также может быть признаком того, что
вам необходимо увеличить значение NMBCLUSTERS. На i386
разумным значением для большинства 100-мегабитных
интерфейсов&nbsp; ethernet (вне зависимости от их
количества) является 8192.&nbsp; 

<ul>
  <strong><p>option NMBCLUSTERS=8192<br>
  </p></strong>
</ul>

<h2><a name="11.2"></a></h2>
<h2>11.2 - Дисковый ввод-вывод</h2>

<p>Производительность диска является значащим фактором в общей производительности 
  компьютера. Это становится особенно важным, если компьютер работает в многопользовательском 
  окружении (например если ваш компьютер задействован в качестве файл-сервера 
  или веб-сервера в большой сети). Хранение данных всегда требует особого внимания, 
  особенно если на вашем диске мало места или вы храните очень ценные данные.<br>
  Для убыстрения работы с диском и защиты от сбоев OpenBSD имеет следующие средства:
<ul>
  <li><a href="#ccd">CCD</a> - Драйвер объединенного диска (Concatenated Disk 
    Driver). </li>
  <li><a href="#raid">RAID</a> - Зеркальные диски</li>
  <li><a href="#buf">Filesystem Buffer </a>- Буферизация файловой системы </li>
  <li><a href="#softu">Soft Updates</a> - Программная синхронизация</li>
</ul>

<p><a name="ccd"></a> </p>

<h3>11.2.1 - Драйвер объединенного диска (CCD)</h3>

<ul>
  <p>Драйвер объединенного диска (подробнее см. <a
  href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;apropos=0&amp;sektion=4&amp;format=html">ccd(4)</a>), 
    позволяет объединить несколько разделов в один логический диск. Это значит, 
    что вы можете использовать несколько разделов (даже если они расположенны 
    на разных устройствах !) как один большой диск. Аналогом CCD в коммерческих 
    Unix-системах является технология LVM (Logical Volume Management, логическое 
    управление разделами).</p>
  <p>Во-первых, для использования CCD необходима поддержка в ядре - для этого 
    в конфигурации ядра должна присутствовать следующая строка (в ядре GENERIC, 
    поддержка ССD уже включена): 
  <ul>
    <pre>
<strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>
  </ul>
  <p>Цифра 4, в данном случае, обозначает что мы настраиваем возможность использования 
    до четырех ccd-устройств (т.е. до четырех объединенных дисков).<br>
    Во-вторых, надо определить разделы на реальных дисках (все содержимое этих 
    разделов будет утеряно) , которые вы решили объединить. Используя disklabel(8), 
    определите для этих разделов тип &quot;ccd&quot;. На некоторых архитектурах 
    disklabel может этого не позволить, в этом случае, выставьте их тип разделов 
    в &quot;ffs&quot;.<br>
  </p>
  <p>Если с помощью CCD вы пытаетесь увеличить производительность (объединяя несколько 
    физических устройств), учтите, что оптимального быстродействия можно достигнуть 
    только с одинаковыми моделями дисков и установками в disklabel. </p>
  <p>Далее - внесите сведения о новом диске в /etc/ccd.conf (за дополнительной 
    информацией обратитесь к <a
  HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;apropos=0&amp;sektion=8&amp;format=html">ccdconfig(8)</a>), 
    например: 
  <ul>
    <pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre>
  </ul>
  <p>(В данном случае мы определили новый диск ccd0, который является объединением 
    /dev/sd2e и /dev/sd3e)<br>
    Чтобы изменения возымели силу, выполните: 
  <ul>
    <pre># ccdconfig -C
</pre>
  </ul>
  <p>Теперь у нас есть новый диск ccd0 (первый из четырех возможных).<br>
    При каждом старте CCD будет читать файл /etc/ccd.conf, и пока этот файл сущесвует, 
    мы будем иметь доступ к описанным в нем дискам.<br>
    Теперь вы можете, используя disklabel, создать на новом диске необходимые 
    разделы. Также как и на обычном диске, не используйте раздела 'c', и убедитесь, 
    что ваши разделы начинаются как минимум на один циллиндр дальше начала диска. 
  </p>
</ul>

<p><br>
<a name="raid"></a> </p>

<h3>11.2.2 - Зеркальные диски RAID (Redundant Arrays of Inexpensive Disks)</h3>

<ul>
  <p>&nbsp;</p>
  <p><small>(кто не знает - RAID - система дублирования информации на нескольких 
    &quot;зеркальных&quot; дисках. Это защищает данные от повреждений - при повреждении 
    данных на одном диске они могут быть считаны с другого, а также увеличивает 
    производительность засчет параллельного доступа п.п.)</small><br>
    <br>
    О поддержке RAID вы можете прочитать на страницах man <a
  href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a> 
    и <a
  href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>. 
    Поддержка RAID под OpenBSD основана на порте Грега Остера CMU <a
  HREF="http://www.pdl.cs.cmu.edu/RAIDframe/">RAIDframe</a> для <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD</a> 
    (Greg Oster's NetBSD port of the CMU RAIDframe software). OpenBSD поддерживает 
    RAID уровней 0, 1, 4 и 5.</p>
  <p>Как и CCD, RAID требует поддержки в ядре (это увеличит ядро i386 приблизительно 
    на 500K !). Но в отличие от CCD, поддержка RAID не включена в ядро GENERIC, 
    вы должны добавить в конфигурацию ядра следуюшую строку: 
  <ul>
    <pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre>
  </ul>
  <p>Настрока RAID на некоторых операционных системах бывает, мягко говоря, болезненой. 
    Но это не относится к RAIDframe. О подробностях читайте <a
  href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a> 
    и <a
  href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>. 
    Настройка RAID имеет много опций и возможных вариантов конфигурации, детальный 
    разбор которых, выходит за рамки этого документа.<br>
  </p>
</ul>

<p><br>
<a name="buf"></a> </p>

<h3>11.2.3 - Буферизация файловых систем</h3>

<ul>
  <p>Вы можете увеличить быстродействие диска, увеличив количество памяти (если 
    у вас ее много), отведенное под дисковый буфер. Для этого в конфигурации ядра 
    есть опция BUFCACHEPERCENT, определяющая какая часть памяти (в процентах) 
    будет использована для буфера (и соответственно, не сможет быть использована 
    для других целей). Эта опция имеет смысл, только если разрешена буферизация 
    файловых систем (Unified Buffer Cache). <br>
    Чтобы изменить размер буфера добавьте в конфигурацию ядра строку:<br>
  <ul>
    <p><strong>option BUFCACHEPERCENT=30</strong><br>
    </p>
  </ul>
  <p>В данном случае вы установите использование под буфер 30% памяти. Конечно, 
    вы можете установить и меньшее значение - например 5 % (как это установлено 
    по-умолчанию) или больше - 50% или более. </p>
</ul>

<p><br>
<a name="softu"></a> </p>

<h3>11.2.4 - Програмная синхронизация (soft updates)</h3>

<ul>
  <p>Другим средством ускорения диска является программная синхронизация (soft 
    updates).<br>
    Традиционно, одна из наиболее медленных операций в файловой системе BSD, это 
    синхронизация мета-информации (которая выполняется при создании и удалении 
    файлов и каталогов). При програмной&nbsp;синхронизации, метаинформация обновляется 
    в оперативной памяти (RAM), и не записывается на диск при каждой операции.<br>
    [Другой эффект этого - метаинформация на диске, необязательно должна соответсвовать 
    реальной. <small>(ориг. - Another effect of this is that the metainfo on disk 
    should always be complete, although not always up to date.)</small>]. Так 
    что после аварийного выключения fsck запускаться не будет, вместо этого будет 
    запущена ее фоновая версия, которая восстановит метаинформацию в памяти. Это 
    означает, что перезагрузка сервера произойдет быстрее, т.к. вам не придется 
    ждать fsck ! (правда, OpenBSD, пока, не поддерживает этой возможности). Прочитать 
    больше о программной синхронизации (soft updates) можно в соответствующем 
    <a href="faq14.html#14.5">разделе FAQ</a>. <br>
  </p>
</ul>

<p><a name="11.3"></a> </p>

<h2>11.3 - Настройка kmem</h2>

<p>Данный раздел перемещен в <a HREF="faq11-2.5.html#11.2">раздел информации об 
  OpenBSD 2.5</a>.<br>
</p>

<p><a name="11.4"></a> </p>

<h2>11.4 - Выбор оборудования</h2>
<i>

<p>(NB: это раздел более относится к архитектуре i386 или &quot;PC&quot; .Что 
  не говори - другие архитектуры не дают&nbsp; вам столь широкого выбора ! )</p>
</i>
<p>Произволительность ваших приложений более всего зависит от ОС и средств, ею 
  предоставляемых. Это, видимо, одна из причин, почему вы используете OpenBSD. 
  Производительность ваших приложений также сильно зависит от вашего оборудования.&nbsp; 
  Но для многих людей, отношение цена/производительность компьютеров на процессорах 
  AMD Athlon или Intel Pentium III гораздо меньше отношения цена/производительность 
  Sun UltraSparc 60 ! Цена OpenBSD, конечно, вне конкурренции ...</p>

<p>Когда вы покупаете новый PC, вне зависимости от того, покупаете вы его по частям 
  или полностью собранным, вы в первую очередь, хотите убедиться, что покупаете 
  надежные компоненты. В мире PC это не так просто. <strong>Плохие, ненадежные 
  или несовместимые между собой компоненты оборудования могут послужить причиной 
  плохой работы OpenBSD и частым сбоям</strong>. Лучший совет, который мы можем 
  дать - будьте осторожны, покупайте компьютеры и компоненты рекомендованные авторитетными 
  лицами, которым вы доверяете. Иногда, экономя немного денег, вы сильно теряете 
  в качестве ! </p>

<p>Вот основные моменты, следуя которым вы добьетесь от вашей системы оптимального 
  быстродействия: 
<ul>
  <li>Используйте несколько дисков. 
    <p>Вместо покупки одного диска 20GB, купите несколько дисков 9GB. Это может 
      обойтись вам дороже, но использование нескольких приводов уменьшит время 
      доступа к данным. Также, с несколькими приводами, вы можете получить большую 
      надежность и быстрый доступ к данным используя RAID. </p>
  </li>
  <li>Используйте SCSI (SCSI-диски), если вам нужна очень большая скорость диска 
    или очень большой объем. 
    <p>IDE-диски обычно работают на 5400 rpm (oб/мин), или 7200 rpm для новых 
      дисков. Даже используя IDE-диски класса high-end, не стоит ожидать скорости 
      передачи данных более чем 15-20 мегабайт в секунду от одного диска. Используя 
      high-end SCSI-диски (дорогостоящие диски 10000 rpm), вы можете достигнуть 
      большей скорости передачи данных. Однако, использование medium- или low-end 
      SCSI-дисков - является просто потерей денег, IDE-диски будут служить вам 
      так же если не лучше.&nbsp; </p>
    <p>Если вы строите сервер, и вам нужно более 20GB дискового пространства вам 
      также может понадобится SCSI. IDE ограничивает вас двумя дисками на один 
      контроллер. Кроме этого, эти два диска делят доступ (concurrent access), 
      что может негативно отразиться на производительности ввода-вывода. Ограничение 
      Wide SCSI - 15 устройств на один контроллер ! Хотя SCSI и стоит дороже, 
      гибкость и производительность может стать решающим фактором для некоторых 
      систем.<br>
    </p>
  </li>
  <li>Используйте SDRAM вместо DRAM. 
    <p>Это более относится к PC. Большинство архитектур не предоставляют выбора, 
      какой вид памяти вы можете использовать. Некоторые PC еще до сих пор это 
      позволяют. Вы получите большую производительность с SDRAM чем с DRAM (древние 
      SIMM-линейки). Если ваша система поддерживает RDRAM или другой новый тип 
      памяти (RAM), тогда вы уже на шаг впереди ...&nbsp; </p>
  </li>
  <li>Используйте память с поддержкой ECC или четности (parity) 
    <p>Четность позволяет линейке памяти определить, что данные в ней повредились. 
      ECC кроме этого, может исправить эти ошибки &quot;на лету&quot;.<br>
      Этот совет, также, скорее относится к PC. Большинство архитектур просто 
      требуют память с четностью или ECC. Некоторые (не-PC) компьютеры просто 
      отказываются загружаться с памятью, не поддерживающей четность. Если вы 
      не используете ECC/parity-память вы можете столкнуться со сбоями (частота 
      которых зависит от качаства памяти), связанными с повреждением данных в 
      памяти. <br>
      Некоторые производители &quot;дешевой памяти для PC&quot; даже не производят 
      ECC-вариантов ! Будет лучше, если вы будете избегать таких производителей. 
      <br>
      Производители PC обычно выпускают несколько линий продуктов, разделенных 
      на &quot;серверы&quot; и &quot;рабочие станции&quot;, где &quot;серверы&quot; 
      поставляются с ECC-памятью в архитектуре. Производители же рабочих станций 
      станций под Unix используют память с четностью или ECC во всех линиях своей 
      продукции. </p>
  </li>
  <li>Избегайте ISA-устройств. 
    <p>Хотя большинство людей избегают использования ISA-устройств, из-за их устарелости 
      и сложностей конфигурирования, эти устройства до сих пор существуют. Если 
      вы используете шину ISA для дискового или сетевого контроллера (или что 
      еще хуже - для обоих), помните - что шина ISA сама по себе является &quot;бутылочным 
      горлышком&quot; (aka &quot;узким местом&quot;) производительности компьютера. 
      Если вам нужна скорость - используйте PCI. Конечно, до сих пор существуют 
      хорошо работающие ISA-карты. К сожалению, большинство из них - звуковые 
      карты и мультипортовые платы (т.е. платы на 4-8 последовательных портов). 
    </p>
  </li>
  <li>Избегайте дешевых PCI сетевых карт. 
    <p>OpenBSD поддерживает большинство дешевых PCI сетевых карт. Эти адаптеры 
      будут отлично работать в домашних системах, но в деловых или исследовательских 
      системах они работают средне или медленно. Если вам требуется высокая пропускная 
      способность и высокая надежность, вам лучше купить качественные PCI сетевые 
      карты. К сожалению, некоторые дорогие именитые адаптеры (такие как 3COM 
      XL-серия) ненамного лучше дешевых адаптеров. Наиболее популярный 10/100 
      Mbps сетевой адаптер - Intel EtherExpress PRO/100.<br>
    </p>
  </li>
</ul>

<p><a name="11.5"></a> </p>

<h2>11.5 - Почему мы не используем асинхронного монтирования?</h2>

<p><small><strong>Прим. перев:</strong> Добавлю пару слов от себя. Асинхроное 
  монтирование, о котором идет речь ниже - специальный режим монтирования (для 
  ускорения работы с диском), допускающим выполнение следующей дисковой операции 
  до окончания предыдущей, группируя одиночные запросы на запись данных файловой 
  системы, выполняя их по несколько за раз. Это несомненно ускоряет работу с диском 
  (из-за уменьшения числа фактических обращений). Но реально на диск, записываемые 
  данные могут попадать в произвольном порядке. В идеальном случае ничего не должно 
  случится - все данные раньше или позже попадут на диск. Однако в реальной ситуации 
  всегда может выключится свет или произойти другой аппаратный сбой, в результате 
  чего одному богу известно, какие данные окажутся реально записанными, а какие 
  нет, что приведет к тому, что вы можете не найти на диске ни старых данных (файлов, 
  каталогов), ни новых, или найти их поврежденными ! В самом тяжелом случае могут 
  оказаться некорректными корневые структуры файловой системы и вы можете сделать 
  ручкой всему разделу.<strong><br>
  </strong></small><strong><br>
  Вопрос:</strong> &quot;У меня есть пакет (package) который время от времени 
  обращается к нескольким сотням файлов сразу, почему ему постоянно не хватало 
  быстродействия диска. Но после того, как я просто сделал &quot;mount -u -o async 
  /&quot;, этот пакет смог работать нормально ! <br>
  Чем асинхронное монтирование вам так не приглянулось, и почему оно не включено 
  по-умолчанию (как включено внекоторых других юникс-системах) ? Убежден, что 
  это наиболее простой и поэтому безопаснейший путь для улучшения производительности 
  некоторых приложений.&quot;<br>
  <br>
  <strong>Ответ:</strong> &quot; Асинхронное монтирование, естественно, быстрее, 
  чем синхронное, но оно, также менее безопасно. Что происходит в случае, если 
  выключается питание ? Или если случается аппаратный сбой ? Погоня за скоростью 
  не должна приносить в жертву надежности и стабильности системы. Посмотрите страницу 
  man <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;apropos=0&amp;sektion=8&amp;format=html">mount(8)</a>.&quot;</p>

<pre>
	     async   Весь ввод/вывод в файловую систему будет проводится
		     асинхронно. Это опасный флаг, так как он не гарантирует
		     сохранения целостности файловой структуры на диске.
		     Он не должен использоваться, если ваша система не
		     подготовлена ко всем возможным сбоям. Наиболее часто
		     этот флаг используется для убыстрения утилиты restore(8),
		     которую таким образом можно ускорить вдвое.
</pre>

<p>С другой стороны, когда вы сохраняете данные, по которым вы можете восстановить 
  нормальное состояние файловой системы (и продолжить работу с того же места) 
  после сбоя системы, вы можете увеличить скорость работы, используя отдельный 
  раздел смонтированный асинхронно, только для данных. Конечно, если вы не имете 
  ничего против того, чтобы потерять все данные на этом разделе, если что-то пойдет 
  не так ... </p>

<p><a name="11.6"></a></p>

<h2>11.6 - Настройка разрешения монитора под XFree86</h2>

<p>Настройка X-сервера для работы на допустимом разрешении, возможна для многих 
  multi-sync мониторов. Возможно вы пытались сделать это стандартными утилитами 
  xf86config или XF86Setup, но не достигли желаемого результата. Один из наиболее 
  болезненных аспектов - тривиальная настройка монитора для работы в требуемом 
  разрешении, и настройка частоты вертикального сканирования (т.е. частоты кадров) 
  хотя-бы на 72-75 Гц (Hz) - на частоту при которой человек гораздо меньше замечает 
  мерцания экрана. Или, например, на очень низкую частоту кадров. Например если 
  установить&nbsp; частоту 50 Гц, то сигнал может выводится на видео без мерцания, 
  но методы, которыми это достигается не поддерживаются стандартной документацией 
  и инструментами XFree86.<br>
<br>
  Наконец, на разрешениях, которые нормальные люди используют на недорогих VGA 
  мониторах (800x600, 1024x768, 1152x900, 1280x1024),&nbsp; возможно (по крайней 
  мере на новых мониторах) использовать частоту кадров 85 Гц и более, для получения 
  черезвычайно чистого и четкого изображения. X-сервер XFree86 имеет механизм 
  который позволяет вам детально определить видеорежим, который вы хотите использовать, 
  это строки описания режимов &quot;ModeLine&quot;. Строка ModeLine имеет четыре 
  секции: 
<ul>
  <li>частота пикселов (pixel clock), одно число</li>
  <li>&quot;горизонтальные временые характеристики&quot;
    (horizontal timings) четыре числа</li>
  <li>&quot;вертикальные временные характеристики&quot;
    (vertical timings) четыре числа</li>
  <li>необязательная секция - список флагов режима -
    например черезстрочная развертка (interlace), двойное
    сканирование (double scan) и другие ... детали ModeLine
    смотрите в странице man <a
    HREF="http://www.openbsd.org/cgi-bin/man.cgi?query=XF86Config&amp;sektion=5">XF86Config(5)</a>.</li>
</ul>

<p>Создание строк ModeLine руками - весьма неблагодарное занятие ... К счастью 
  есть скрипт который сделает это за вас. Это <a
HREF="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">Colas XFree86 
  ModeLine Generator</a> (&quot;Генератор ModeLine для XFree86&quot;). Перед использованием 
  генератора, вы должны выяснить пределы вертикальной и горизонтальной синхронизации 
  для вашего монитора. Их часто можно найти в документации к монитору или на веб-сайте 
  производителя. Если вы не можете найти ничего из перечисленного, просто поищите 
  по Интернету марку и модель своего монитора - некоторые люди, публикуют списки 
  с подобной информацией. </p>

<p>Например вы имеете монитор Dell D1226H. В агонии разыскав веб-сайт Dell вы 
  выяснили, что он имеет разброс частот 30-95 кГц (kHz) по горизонтали и 50-160 
  Гц по вертикали. Посетите страницу генератора ModeLine и введите данную информацию. 
  Далее вам необходимо ввести минимальную вертикальную чатоту (частоту кадров), 
  которую вы хотите иметь. Мы советуем вам частоты 72 Гц и выше, потому, что они 
  не должны вызывать видимого мерцация. Чем выше частоты вы выберите, тем более 
  чистым будет изображение. </p>

<p>Получив всю эту информацию, скрипт сгенерирует строки ModeLine для для каждого 
  возможного разрешения с пропорциями 4x3, которые поддерживает ваш монитор, с 
  частотой кадров равной или более высокой чем та которую вы ввели. Если мы введем 
  спецификации Dell и минимальную частоту 75 Гц. Скрипт сгенерирует что-то вроде 
  следующего: </p>

<pre>
ModeLine &quot;320x240&quot; 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine &quot;328x246&quot; 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine &quot;816x612&quot; 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine &quot;824x618&quot; 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine &quot;832x624&quot; 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine &quot;840x630&quot; 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine &quot;848x636&quot; 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine &quot;1048x786&quot; 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine &quot;1056x792&quot; 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine &quot;1064x798&quot; 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine &quot;1432x1074&quot; 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine &quot;1576x1182&quot; 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine &quot;1584x1188&quot; 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>Как мы видим, этот монитор не способен строить изображение разрешением 1600x1200 
  на частоте кадров 75 Гц. Поэтому, если вы все-таки хотите иметь разрешение 1600x1200, 
  спуститесь на более низкую частоту кадров (вот что мы получим в дополнение, 
  опустившись до 70 Гц) </p>

<pre>
ModeLine &quot;1592x1194&quot; 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine &quot;1600x1200&quot; 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine &quot;1608x1206&quot; 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine &quot;1616x1212&quot; 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine &quot;1624x1218&quot; 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine &quot;1632x1224&quot; 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine &quot;1640x1230&quot; 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine &quot;1648x1236&quot; 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>Здесь мы видим, что монитор может работать на
1600x1200 @ 74 Гц, когда частота пиксела (pixel clock)
ограничена 200 MГц. Установите частоту,
определенную пределами монитора. </p>

<p>После того, как вы получили строки ModeLine, поместите их файл /etc/XFree86Сonfig. 
  Закоментируйте старые строки, так чтобы вы могли их вернуть назад, если новые 
  не будут работать. Теперь выберите разрешение, с которым вы, собственно, хотите 
  работать. Для этого, во-первых определите работает ли X в ускореном (accelerated) 
  режиме (в котором он работает с большинством видеокарт), чтобы узнать, какую 
  секцию <tt>&quot;Screen&quot;</tt> необходимо отредактировать. Или просто отредактируйте 
  все секции Screen. </p>

<pre>
Section &quot;Screen&quot;
   Driver          &quot;Accel&quot;
   Device          &quot;Primary Card&quot;
   Monitor         &quot;Primary Monitor&quot;
   DefaultColorDepth 32
   SubSection &quot;Display&quot;
      Depth        32
      Modes        &quot;1280x1024&quot; &quot;1024x768&quot;
   EndSubSection
</pre>
<p>Первое разрешение, которое вы увидите в строке после &quot;Modes&quot; - режим, 
  в котором X стартует. Вы можете переключатся между разрещениями указанными здесь, 
  нажатием Ctrl-Alt-&quot;Серый -&quot; (на цифровой клавиатуре) или Ctrl-Alt-&quot;Серый 
  +&quot;. Секция выше определяет глубину цвета (32 бита), в которой X и попробует 
  стартовать (директивой DefaultColorDepth; без нее X стартует в 8-битном цветовом 
  режиме). Первое разрешение, которое X попробует использовать - 1280x1024 (т.е. 
  в порядке перечисления в строке Modes). Имейте ввиду, что &quot;1280x1024&quot; 
  всего-лишь ярлык для сответствующей строки ModeLine. &nbsp; </p>

<p>Генератор ModeLine имеет опции для смягчения временных характеристик для старых 
  или маленьких мониторов, и также имеет возможность предоставить строки ModeLine 
  для определенных разрешений. Временные характеристики устанавливаемые генератором 
  ModeLine, не всегда подходят для оборудования, которое вы используете. Если 
  изображение слишком высокое, слишком широкое, слишком маленькое, сдвинуто горизонтально 
  или вертикально и настройками монитора это изменить не удается, чтобы скорректировать 
  изображение можно воспользоваться утилитой xvidtune(1), подстроив значения ModeLine 
  для более точного соответствия временным характеристикам вашего монитора. Будьте 
  осторожны в использовании это программы.</p>

<p>На многих современных мониторах нет фиксированного предела частоты писелов, 
  поэтому они часто не печатают спецификаций.Чем выше вы выставляете чатоту, тем 
  более размытыми получаются пикселы на черно-белом изображении. Имея такой монитор, 
  вы можете протестировать различные частоты писела (dotclock), подставляя их 
  в настройки вашей карты (так вы не сможете повредить монитору) и, постепенно 
  уменьшая чатоту, добиться отличного четкого изображения.</p>

<p>Может показаться, что вышеописанная процедура безпричинно усложнена, отчасти, 
  так оно и есть. XFree86 4.0 учитывает это и делает этот процесс гораздо проще, 
  имея множество встроенных режимов и&nbsp; обладая возможностью считывать параметры 
  с Plug&amp;Play-мониторов через DDC и DCC2.<br>
  Однако, к сожалению, версия 4.0 в настояший момент еще не совсем готова - например 
  она еще не поддерживает много видеокарт, которые поддерживались XFree86 3.3.</p>

<p>Скрипт ModeLine-генератора (Colas XFree86 ModeLine Generator) вы можете скачать 
  на <a HREF="ftp://koala.inria.fr/pub/Klone/">ftp://koala.inria.fr/pub/Klone/</a>. 
  Также вам понадобится скачать интерпретатор Klone и собрать его. Вы можете найти 
  его в портах (ports) как lang/klone. Скрипты должны находится в в каталоге scripts 
  в дистрибутиве Klone. (Порт устанавливает их в /usr/local/lib/klone/scripts.) 
</p>

<p>В поставке есть две версии скрипта - первая ориентирована на CGI и идентична 
  скрипту на веб-странице, описанной выше. Вторая версия создает готовый файл 
  XFree86Config, декодирует спецификации монитора введенные в xf86config/XF86Setup 
  (т.е. либо то что вы ввели, либо стандартные настройки), а также позволяет подстраивать 
  существующие строки ModeLine.</p>

<p><font color="#0000e0"><a href="index.html">[Вернуться в главный
индекс]</a> <a href="faq12.html">[Секция 12.0 - Для опытных
пользователей]</a> <a href="faq10.html">[Секция 10.0 -
Системное Администрирование]</a> </font></p>

<hr>
<p>

 <a href="index.html"><img height="24" width="24" src="../images/back.gif" border="0" alt="[back]"></a><a
href="mailto:www@openbsd.org">www@openbsd.org</a> <br>
<small>$OpenBSD: faq11.html,v 1.12 2000/10/18 15:37:14 ericj Exp $</small> </p>
</body>
</html>
