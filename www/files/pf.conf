# $RuOBSD$
#
# Пример настройки PF. В данном примере mtd0 имеет реальный адрес,
# а rl0 внутренний адрес в локальной сети, которая должна транслироваться
# во внешний адрес.

# Определение сетевых интерфейсов, внутренних сетей и обслуживаемых
# TCP и UDP сервисов.
#
ext_if		= "mtd0"
int_if		= "rl0"
pvt_nets	= "{ 10/8, 127/8, 172.16/12, 192.168/16 }"
udp_svcs	= "{ domain, ntp }"
tcp_svcs	= "{ ssh, smtp, ftp, telnet, domain, www, ntp, pop3s, imaps, \
	6667, >= 49152 }"


# Создание таблицы спамерских хостов/сетей. Данная таблица используется
# управляется программой spamd-setup.
#
table <spamd> persist

# Произвести полную пересборку фрагментов входящего трафика.
#
scrub in on $ext_if all fragment reassemble

# Включить трансляцию адресов для внутренней сети, настроить
# transparent proxy для FTP (подразумевается что inetd.conf настроен
# для запуска ftp-proxy).
#
nat on $ext_if inet from $int_if:network to any -> ($ext_if)
rdr on $int_if inet proto tcp from $int_if:network to any port ftp -> \
	(lo0) port 8021

# Переадресовать входящие SMTP коннекты от спамеров на spamd.
# Пометить тэгом SPAMD (нужен чтобы пропустить именно эти коннекты к
# spamd, не открывая всем остальным порта, на котором он висит).
#
rdr on $ext_if inet proto tcp from <spamd> to port smtp tag SPAMD -> \
	(lo0) port spamd
pass in quick on $ext_if proto tcp tagged SPAMD keep state

# По умолчанию запретить весь трафик и писать сообщение в log. Вернуть
# RST для TCP пакетов и ICMP ошибку для UDP.
#
block return log on $ext_if all

# Молча блокировать входящие пакеты на которые мы не сможеи ответить
# в виду отсутствия роутинга (всякое в жизни бывает :))
#
block in quick from no-route to any

# Не выпускать во внешний мир пакеты, которые идут не от нашего
# адреса - это или провокация или что-то работает неправильно (например
# не настроена трансляция адресов).
#
block out log quick on $ext_if inet from ! ($ext_if) to any

# Блокировать входящие пакеты с адресов которые могут быть только в
# локальных сетях.
#
block in log quick on $ext_if from $pvt_nets to any

# Пропустить ICMP типа PING запроса и сохранить state.
# Другие типы ICMP всегда связаны с TCP или UDP и будут автоматически
# пропускаться в соответствии с их сохраненными state .
#
pass on $ext_if inet proto icmp all icmp-type echoreq code 0 keep state

# Разрешить исходящий TCP/UDP трафик.
#
pass out on $ext_if proto udp all keep state
pass out on $ext_if proto tcp all flags S/SA keep state

# Разрешить входящие TCP/UDP пакеты к обслуживаемым сервисам.
#
pass in on $ext_if proto udp from any to any port $udp_svcs keep state
pass in on $ext_if proto tcp from any to any port $tcp_svcs flags S/SA \
	keep state
