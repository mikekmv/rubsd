# $RuOBSD: pf-dual.conf,v 1.5 2005/11/01 14:57:50 form Exp $
#
# Пример настройки PF для маршрутизатора с двумя внешними каналами
# с трансляцией адресов и переадресацией некоторых сервисов во внутреннюю сеть.
#
# В данном примере также настраивается симметричная маршрутизация для
# правильного возврата пакетов в канал с которого было инициировано соединение
# независимо от настройки default route.
#
#  WAN_1  WAN_2             LAN
#    |      |      +------------+--------
#    |      |      |            |
# +-rl0----rl1----em0-+  +--------------+
# |                   |  |  10.10.10.2  |
# +-------------------+  +--------------+

# Внешний и внутренний интерфейсы.
#
ext_if_a	= "rl0"
ext_if_b	= "rl1"
int_if		= "em0"

# Шлюзы для каналов.
#
ext_gw_a	= "81.1.197.89"
ext_gw_b	= "81.1.226.48"

# TCP/UDP сервисы, обслуживаемые маршрутизатором.
#
tcp_svc		= "ssh smtp domain"
udp_svc		= "domain"

# TCP сервисы, обслуживаемые внутренним сервером.
#
tcp_rdr		= "3389"
host_rdr	= "10.10.10.2"

# Таблицы черного и белого списков для spamd.
#
#table <spamd> persist
#table <spamd-white> persist

# Выполнить нормализацию всех пакетов.
#
scrub in

# Транслировать внутренние адреса в (основной) адрес внешнего интерфейса.
#
nat on $ext_if_a from !(self) -> ($ext_if_a:0)
nat on $ext_if_b from !(self) -> ($ext_if_b:0)

# Пропустить FTP через transparent proxy.
#
rdr on $int_if proto tcp to !(self) port ftp -> 127.0.0.1 port 8021

# Перенаправить адреса из черного списка в spamd.
#
#rdr on $ext_if_a proto tcp from <spamd> to port smtp tag EXT_IF_A \
#	-> 127.0.0.1 port spamd
#rdr on $ext_if_b proto tcp from <spamd> to port smtp tag EXT_IF_B \
#	-> 127.0.0.1 port spamd

# Перенаправить адреса не входящие в белый список в spamd (используется
# в режиме greylist.
#
#rdr on $ext_if_a proto tcp from !<spamd-white> to port smtp tag EXT_IF_A \
#	-> 127.0.0.1 port spamd
#rdr on $ext_if_b proto tcp from !<spamd-white> to port smtp tag EXT_IF_B \
#	-> 127.0.0.1 port spamd

# Переадресовать TCP сервисы, обслуживаемые внутренним сервером.
#
rdr pass on $ext_if_a proto tcp from ($ext_if_a:network) to port { $tcp_rdr } \
	-> $host_rdr
rdr pass on $ext_if_b proto tcp from ($ext_if_b:network) to port { $tcp_rdr } \
	-> $host_rdr
rdr on $ext_if_a proto tcp to port { $tcp_rdr } tag EXT_IF_A -> $host_rdr
rdr on $ext_if_b proto tcp to port { $tcp_rdr } tag EXT_IF_B -> $host_rdr

# Защита от IP spoofing.
#
pass quick on { lo $int_if }
antispoof quick for { lo $int_if }

# По умолчанию блокировать входящий трафик на внешних интерфейсах.
# Для TCP соединений возвращать RST.
#
block in on { $ext_if_a $ext_if_b }
block return-rst in on { $ext_if_a $ext_if_b } proto tcp

# Направить исходящие пакеты в канал, соответствующий адресу источника.
#
pass out route-to ($ext_if_a $ext_gw_a) from ($ext_if_a) \
	to !($ext_if_a:network) keep state
pass out route-to ($ext_if_b $ext_gw_b) from ($ext_if_b) \
	to !($ext_if_b:network) keep state

# Установить маршрут для ответа на входящие пакеты для переадресованых
# TCP сервисов.
#
pass in reply-to ($ext_if_a $ext_gw_a) proto tcp flags S/SA tagged EXT_IF_A \
	keep state
pass in reply-to ($ext_if_b $ext_gw_b) proto tcp flags S/SA tagged EXT_IF_B \
	keep state

# Разрешить входящие ICMP ping пакеты, обслуживаемые UDP и TCP сервисы.
#
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) inet proto icmp \
	icmp-type echoreq code 0 keep state
pass in on $ext_if_a inet proto icmp from ($ext_if_a:network) \
	icmp-type echoreq code 0 keep state
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) proto udp \
	to port { $udp_svc } keep state
pass in on $ext_if_a proto udp from ($ext_if_a:network) to port { $udp_svc } \
	keep state
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) proto tcp \
	to port { $tcp_svc } flags S/SA keep state
pass in on $ext_if_a proto tcp from ($ext_if_a:network) to port { $tcp_svc } \
	flags S/SA keep state
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) inet proto icmp \
	icmp-type echoreq code 0 keep state
pass in on $ext_if_b inet proto icmp from ($ext_if_b:network) \
	icmp-type echoreq code 0 keep state
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) proto udp \
	to port { $udp_svc } keep state
pass in on $ext_if_b proto udp from ($ext_if_b:network) to port { $udp_svc } \
	keep state
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) proto tcp \
	to port { $tcp_svc } flags S/SA keep state
pass in on $ext_if_b proto tcp from ($ext_if_b:network) to port { $tcp_svc } \
	flags S/SA keep state

# Разрешить входящие TCP соединения для FTP proxy.
#
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) proto tcp \
	to port > 49151 flags S/SA user proxy keep state
pass in on $ext_if_a proto tcp from ($ext_if_a:network) to port > 49151 \
	flags S/SA user proxy keep state
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) proto tcp \
	to port > 49151 flags S/SA user proxy keep state
pass in on $ext_if_b proto tcp from ($ext_if_b:network) to port > 49151 \
	flags S/SA user proxy keep state
