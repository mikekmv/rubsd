<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<meta http-equiv="Content-Language" content="ru">
<meta name="copyright" content="Copyright (c) 2000-2002 by OpenBSD.ru">   
<title>Алгоритм Rsync</title>
</head>

<body bgcolor="#ffffff" text="#000000" link="#23238e">

<h2><font color="#e00000">Алгоритм Rsync</font></h2>
<hr>

<h3><font color="#0000e0">Для чего он нужен?</font></h3>

<p>
Современные средства и протоколы удалённого копирования файлов (например
http, ftp, rcp), каждый раз полностью пересылают данные, несмотря на возможно
уже существующею старую версию этих данных. Хотя и возможно воссоздать только
изменения, например с помощью утилиты diff, если существует старая копия
наряду с новой, и тем самым пересылать только изменения, но в практике это не
всегда удобно и часто приводит к ошибкам.

<p>
Задачи алгоритма rsync:
<ol>
  <li>Он должен работать с произвольными данными, не только обычным текстом.
  <li>Размер передаваемых данных должен быть примерно равен размеру diff файла.
  <li>Он должен быстро работать с большими файлами.
  <li>Алгоритм не должен иметь какие либо предварительные знания о статусе
      этих файлов, но должен эффективно находить их возможные сходства.
  <li>Использовать мало ресурсов.
</ol>

<p>
Представим, что у нас имеются файлы <i>A</i> и <i>B</i>, и мы хотим обновить
<i>B</i> таким образом, чтобы его содержимое было идентично содержимому файла
<i>A</i>. Самый простой и очевидный способ - это скопировать <i>A</i> в
<i>B</i>.

<p>
Теперь представим, что эти файлы находятся на двух разных машинах соединённых
медленным каналом связи, например, с помощью dialup модема. Если файл <i>A</i>
большой, копирование <i>A</i> в <i>B</i> будет происходить очень медленно.
Чтобы сделать это быстрей, мы можем сжать <i>A</i>, перед тем как пересылать
его. Но обычный коэффициент сжатия колеблется от 2 до 4, что так же не
подойдёт для нашей медленной связи.

<p>
Предположим, что файлы <i>A</i> и <i>B</i> почти одинаковы (возможно, оба
были получены из одного общего файла). Для увеличения производительности
копирования мы можем воспользоваться преимуществом их сходства. Обычное
решение этой проблемы заключается в том, чтобы пересылать только изменения
между файлами <i>A</i> и <i>B</i> и затем использовать их для реконструкции
фала <i>B</i>.

<p>
Но проблема в том, что для получения этих изменений, необходимо иметь
возможность чтения обоих файлов.  Поэтому, нам нужно иметь оба файла на
одной из сторон нашего соединения.  В противном случае, этот алгоритм
использоваться не может. Для решения этой проблемы и был разработан
алгоритм rsync.

<h3><font color="#0000e0">Алгоритм</font></h3>

<h4>Общий алгоритм</h3>

<p>
На двух разных компьютерах <i>Alpha</i> и <i>Beta</i>, соединённых медленным
каналом связи (например через модем), находятся два файла <i>A</i> и <i>B</i>.

<p>
Структура алгоритма:
<ol>
  <li><i>Beta</i> отсылает некоторые данные <i>S</i> на компьютер <i>Alpha</i>
  <li><i>Alpha</i> сравнивает эти данные с файлом <i>A</i> и отсылает некоторые
      данные <i>D</i> на компьютер <i>Beta</i>
  <li><i>Beta</i> создаёт копию файла <i>A</i> на основе файла <i>B</i>,
      данных <i>S</i> и <i>D</i>
</ol>

<p>
Главный вопрос в том, какую форму примут данные <i>S</i>, как компьютер
<i>Alpha</i> будет использовать <i>S</i> для сопоставления с файлом <i>A</i>
и как <i>Beta</i> будет реконструировать <i>A</i>.

<h4>Алгоритм rsync</h3>

<p>
Алгоритм rsync:
<ol>
  <li><i>Beta</i> разбивает файл <i>B</i> на блоки длиной <i>L</i> (последний
      блок может быть меньше <i>L</i>байт) и вычисляет две сигнатуры <i>Rb</i>
      и <i>Sb</i> для каждого блока, после чего пересылает эти сигнатуры к
      <i>Alpha</i>.
  <li><i>Alpha</i> вычисляет сигнатуры <i>Ra</i> для блоков длинной <i>L</i>,
      для каждого байтового смещения. После чего сравнивает их с <i>Rb</i>.
  <li>Для блоков, чьи <i>R</i> сигнатуры совпали, <i>Alpha</i> вычисляет
      <i>Sa</i> и сравнивает с <i>Sb</i>.
  <li>Если <i>S</i> сигнатуры совпадают, <i>Alpha</i> отсылает уведомление
      с номером совпавшего блока, в противном случае <i>Alpha</i> пересылает
      один байт.
  <li><i>Beta</i> получает номера совпавших блоков из <i>B</i> или одиночные
      байты из файла <i>A</i> и на основе этих данных создаёт копию файла
      <i>A</i>.
</ol>

<p>
Важно понимать, что ключом алгоритма является создание двух сигнатур - быстрой
и стойкой. Быстрая (<i>R</i>) используется как фильтр (на компьютере
<i>Alpha</i> она вычисляется для каждого байтового смещения!). Стойкая 
(<i>S</i>) используется для более точной проверки.

<p>
<center>
<img src="images/rsync.gif" alt="Алгоритм rsync"><br>
Алгоритм rsync.
</center>

<h3><font color="#0000e0">Стойкая сигнатура</font></h3>

<p>
Стойкая сигнатура может не быть быстрой, так как вычисляется только при
совпадении простой, быстрой сигнатуры. Главным свойством стойкой сигнатуры
должна быть минимальная вероятность отказа, иначе говоря, наличия одной и той
же сигнатуры для двух разных блоков.

<p>
Существует множество алгоритмов с такими свойствами, возможно наиболее
известный - это алгоритм хеширования <i>Message Digest</i>. Он часто
используется в криптографических программах.

<h3><font color="#0000e0">Быстрая сигнатура</font></h3>

<p>
Быстрая сигнатура очень важна для эффективности алгоритма rsync. Она работает
как фильтр, предотвращая вычисление стойкой сигнатуры. Основная задача быстрой
сигнатуры - это максимально быстрое её вычисление для каждого байтового
смещения в файле.

<p>
Первоначально, для создания быстрой сигнатуры в rsync было опробовано
простое склеивание первых и последних 4 байт блока. Хотя такой алгоритм
в принципе работал, но был выявлен его серьёзный недостаток. Для определённых
типов данных, например для tar файла, он слишком часто создавал одинаковые
сигнатуры для разных частей файла, что приводило к многократному вычислению
стойкой сигнатуры и как следствие падению производительности всего алгоритма.

<p>
Это привело к необходимости выбора нового алгоритма для вычисления быстрой
сигнатуры, значение которого зависело бы от всех байт блока, но при этом
вычисление оставалось таким же простым и быстрым. Им стал алгоритм похожий
на adler32 от Марка Адлера. Adler32 - алгоритм расчёта контрольных сумм,
похожий на довольно распространённый алгоритм CRC32, но при этом более
быстрый.

<h3><font color="#0000e0">Поиск сигнатур</font></h3>

<p>
Для эффективности поиска используется хеширование быстрой сигнатуры и
трехуровневый поиск. Ключом хеш-функции является значение 32 битной
сигнатуры, а значением сумма двух её (16 битных) половин.

<p>
<center>
<img src="images/search.gif" alt="Поиск сигнатур"><br>
Поиск сигнатур.
</center>

<p>
На первом уровне, формируется хеш-таблица размером в 2^16 элементов.
Ключом хеш-функции является быстрая 32 битная сигнатура. Для каждой 
пары быстрой и стойкой сигнатуры полученной от <i>Beta</i> вычисляется 16
битный хеш 32 битной сигнатуры, после чего все это сортируется согласно
16 битному хешу. Каждый элемент хеш-таблицы указывает на первый элемент
сортированных сигнатур, хеш значения которых совпадают, либо хранит в
себе NULL, если сигнатур с таким хешом нет. Номер элемента хеш-таблицы
соответствует значению хеш-функции, а именно сумме двух половин быстрой
32 битной сигнатуры.

<p>
Затем, для каждого байтового смещения вычисляется быстрая 32 битная
сигнатура и 16 битное хеш-значение. Если элемент хеш-таблицы для
этого хеш-значения не равен NULL, алгоритм поиска переходит на следующий
уровень.

<p>
На втором уровне происходит линейный поиск по сортированному списку
сигнатур, начиная с элемента указанного в хеш-таблице. Мы ищем
быструю 32 битную сигнатуру, чьё значение совпадает с необходимым
нам значением. Поиск прекращается при первом же несовпадении 16
битной сигнатуры. Если мы нашли такую 32 битную сигнатуру, алгоритм
переходит на следующий уровень.

<p>
На третьем уровне, происходит вычисление стойкой сигнатуры для текущего
смещения в файле и сравнение его со значением стойкой сигнатуры в
сортированном списке. При совпадении, предполагается, что мы нашли
блок в файле <i>A</i>, который есть в файле <i>B</i>. Фактически, блоки могут
быть различны, но вероятность этого очень мала.

<p>
При совпадении блоков, <i>Alpha</i> отсылает <i>Beta</i> данные из файла
<i>A</i> между текущим смещением и предыдущим совпадением, а также индекс
совпавшего блока который есть в <i>B</i>. Эти данные отсылаются сразу
же при нахождении совпадения.

<p>
Если совпадения найдено не было для текущего смещения в файле <i>A</i>,
вычисляется быстрая сигнатура для следующего байтового смещения и
процедура поиска повторяется. При совпадении, смещение увеличивается
на размер совпавшего блока и поиск продолжается.


<h3><font color="#0000e0">Реконструкция файла</font></h3>

<p>
Одна из простых частей алгоритма rsync - реконструкция файла. После того, как
компьютер <i>Beta</i> отсылает сигнатуры, <i>Alpha</i> присылает байты из файла
<i>A</i> или сообщения, которые содержат номера совпавших блоков.

<p>
Для реконструкции файла <i>B</i>, нам необходимо последовательно вписывать
полученные байты в файл и при получении сообщения о совпавшем блоке
вписывать целый блок из старого файла. Реконструкция не производится
непосредственно в старом файле, так как нам необходим произвольный доступ
к старым данным. Для реконструкции создаётся временный файл, который
затем переименовывается.

<h3><font color="#0000e0">Конвейерная обработка</font></h3>

<p>
Важным фактором быстродействия является задержка между пересылаемыми файлами.
Обычно используемые протоколы передачи данных, такие как ftp, rcp или rdist
обрабатывают каждый файл как отдельную операцию, тем самым ожидая подтверждения
о доставке текущего файла, перед тем как обрабатывать следующий.

<p>
При использовании большего количества маленьких файлов (например обычное
зеркалирование Web сайта) для пересылки через Internet, это время ожидания
может сыграть роковую роль. Чтобы избежать этого, мы можем пересылать не
ожидая подтверждения. Этот метод также известен, как конвейерная обработка.

<p>
<center>
<img src="images/pipe.gif" alt="Схема конвейерной обработки"><br>
Схема конвейерной обработки.
</center>

<p>
Процесс разбивается на 3 части - Generator, Sender и Receiver. Generator
запускается на компьютере <i>Beta</i> и генерирует сигнатуры для всех файлов,
которые необходимо переслать, и отсылает эти сигнатуры к <i>Alpha</i>. Sender
запущенный на <i>Alpha</i> получает сигнатуры и отсылает сообщения о совпавших
блоках или целые байты <i>Beta</i>. Receiver запущенный на <i>Beta</i>
реконструирует файл, после чего, он связывается с Generator, чтобы сообщить
об успешной передачи файла, либо передать ему, что определённый файл
необходимо обработать заново.

<h3><font color="#0000e0">Заключение</font></h3>

<p>
Алгоритм rsync предоставляет эффективное решение проблемы удалённого
обновления файлов. Метод двух сигнатур используемый в алгоритме позволяет
эффективно находить совпадения на любом смещении файла. Алгоритм гарантирует
точность передачи подтверждая подлинность блока стойкой сигнатурой.

<h3><font color="#0000e0">Используемая литература</font></h3>

<p>
<ol>
<li><a href="http://rsync.samba.org/tech_report/">Rsync technical report</a>. Andrew Tridgell и Paul Mackerras. 1998г.
<li><a href="http://samba.org/~tridge/phd_thesis.pdf">Efficient Algorithms for Sorting and Synchronization</a>. Andrew Tridgell. 2000г.
<li><a href="http://www.gzip.org/zlib/zlib_tech.html">Zlib Technical Details</a>. Jean-loup Gailly и Mark Adler.
</ol>

<p>
<hr>
<a href="index.html"><img height=24 width=24 src="../images/back.gif" border=0 alt="OpenBSD.ru"></a>
<a href="mailto:www@openbsd.ru">www@openbsd.ru</a>
<br>
<small>$RuOBSD: rsync.html,v 1.2 2002/07/19 11:18:29 dfa Exp $</small>

</body>
</html>
